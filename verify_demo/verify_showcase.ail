module verify_demo/verify_showcase

-- Static Contract Verification Showcase
-- Demonstrates AILANG's Z3-powered `ailang verify` command.
--
-- This module contains pure functions with contracts that produce
-- all four verification states: VERIFIED, VIOLATION, SKIPPED, ERROR.
--
-- Run:
--   ailang verify verify_demo/verify_showcase.ail           # Static proof
--   ailang verify --verbose verify_demo/verify_showcase.ail  # Show SMT-LIB
--   ailang verify --json verify_demo/verify_showcase.ail     # JSON output

-- ─── VERIFIED: Z3 proves these hold for ALL valid inputs ───

-- Clamp a price to a [min, max] range.
-- Z3 proves: result is always >= min when min <= max.
export pure func clampPrice(price: int, min: int, max: int) -> int
  requires { min >= 0, max >= min }
  ensures { result >= min, result <= max }
{
  if price < min then min
  else if price > max then max
  else price
}

-- Apply tax in basis points (1 bps = 0.01%).
-- 500 bps = 5%. Integer arithmetic avoids floating-point imprecision.
-- Z3 proves: result is always >= the original amount (tax adds, never subtracts).
export pure func applyTax(amount: int, rateBps: int) -> int
  requires { amount >= 0, rateBps >= 0 }
  ensures { result >= amount }
{
  amount + (amount * rateBps) / 10000
}

-- Safe subtraction that floors at zero.
-- Z3 proves: result is never negative.
export pure func safeSubtract(a: int, b: int) -> int
  requires { a >= 0, b >= 0 }
  ensures { result >= 0 }
{
  if a >= b then a - b
  else 0
}

-- Classify a quantity into a discount tier.
-- Z3 proves: returned discount percentage is always 0..30.
export pure func tierDiscount(qty: int) -> int
  requires { qty >= 0 }
  ensures { result >= 0, result <= 30 }
{
  if qty >= 100 then 30
  else if qty >= 50 then 20
  else if qty >= 10 then 10
  else 0
}

-- Validate that an age is within an accepted range.
-- Z3 proves: if preconditions are met, result is in [0, 150].
export pure func validateAge(age: int) -> int
  requires { age >= 0, age <= 150 }
  ensures { result >= 0, result <= 150 }
{
  age
}

-- Tax bracket calculation using match on enum-like values.
-- Z3 proves: result is always non-negative when income >= 0.
export pure func calculateIncomeTax(income: int, bracketPct: int) -> int
  requires { income >= 0, bracketPct >= 0, bracketPct <= 50 }
  ensures { result >= 0 }
{
  (income * bracketPct) / 100
}

-- Absolute difference between two prices.
-- Z3 proves: result is always non-negative.
export pure func priceDifference(a: int, b: int) -> int
  ensures { result >= 0 }
{
  if a >= b then a - b
  else b - a
}

-- ─── VIOLATION: Z3 finds a counterexample ───

-- INTENTIONALLY BUGGY: claims result >= 0, but when discount > price
-- the subtraction goes negative. Z3 will find a counterexample.
export pure func brokenDiscount(price: int, discount: int) -> int
  requires { price >= 0, discount >= 0 }
  ensures { result >= 0 }
{
  price - discount
}

-- ─── MORE VIOLATIONS: subtle bugs Z3 catches ───

-- BUGGY: ceiling division to "round up" the per-person share.
-- Developer wants nobody to underpay, so they round up.
-- But rounding up means result * people can EXCEED total.
-- Z3 finds: total=1, people=2 → ceiling(1/2)=1, but 1×2=2 > 1.
export pure func splitBill(total: int, people: int) -> int
  requires { total >= 0, people >= 1 }
  ensures { result * people <= total }
{
  (total + people - 1) / people
}

-- BUGGY: claims result is strictly positive, but zero slips through.
-- Classic off-by-one on the boundary: developer wrote > 0 but
-- the clamping logic returns exactly 0 when x is negative.
-- Z3 finds: x = 0 → result = 0, but ensures requires result > 0.
export pure func clampPositive(x: int) -> int
  ensures { result > 0 }
{
  if x <= 0 then 0
  else x
}

-- ─── VERIFIED via bounded recursion unrolling ───

-- Recursive function: Z3 unrolls the recursion up to depth 10
-- and proves result >= 1 for all n in [0, 10].
-- Previously SKIPPED — now VERIFIED with --verify-recursive-depth.
export pure func factorial(n: int) -> int
  requires { n >= 0, n <= 10 }
  ensures { result >= 1 }
{
  if n <= 1 then 1
  else n * factorial(n - 1)
}
