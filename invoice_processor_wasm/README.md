# AILANG Document Extractor

AI-powered structured data extraction from documents, validated by [AILANG](https://ailang.sunholo.com/) contracts and effects via WebAssembly. Upload any document — text, image, or PDF — define a schema (or let AI detect one), and get validated, type-safe extraction results.

**100% local. 100% AI-coded.** Nothing leaves your browser except the API call to the AI provider you choose.

**[Try it live →](https://sunholo-data.github.io/ailang-demos/)**

![AILANG Document Extractor](assets/extraction-demo-ui.png)

## What This Demonstrates

This demo showcases AILANG's effect system, contracts, and stdlib working together in a real extraction pipeline — all running client-side via WebAssembly. The entire application — every line of HTML, CSS, JavaScript, and AILANG — was generated by AI using Claude Code.

- **Fully Local** — everything runs in your browser via WebAssembly. No server, no backend, no data leaves your machine except the AI API call
- **AI Effect** (`! {AI}`) — the AI provider is abstracted behind AILANG's effect system. This demo uses Gemini Flash, but AILANG supports any provider — swap `--ai gemini-2-5-flash` for `--ai claude-haiku-4-5` or `--ai gpt5-mini` or even a local model. The extraction code doesn't change
- **AILANG Validates Everything** — AI is stochastic; AILANG is deterministic. Every AI extraction result passes through AILANG's contract system (`requires`/`ensures`), type-safe JSON parsing (`std/json` with `Option` returns), and field-level validation before reaching the user
- **Capability Security** — the WASM sandbox has zero network or filesystem access by default. The AI capability is explicitly injected by the JavaScript host — this is AILANG's deny-by-default security model in action
- **Multimodal** — images and PDFs are processed via base64 through AILANG's `std/ai.call()`, using the same pipeline as text. Base64 is just a string — AILANG passes it through, the host interprets it
- **100% AI-Coded** — this entire demo was built by AI (Claude Code), from the WASM integration layer to the pipeline orchestrator to the CSS design system. AILANG's type system and contracts make AI-generated code trustworthy

## How It Works

```
Document (text/image/PDF) → Schema definition
  → AILANG compiles schema to module (pure)
  → WASM loads module + stdlib
  → AI extracts fields via ! {AI} effect → any AI provider
  → AILANG validates with contracts (pure)
  → Structured, validated output
```

The AI provider is pluggable — AILANG's `! {AI}` effect abstracts the provider. In the browser, JavaScript registers a Gemini handler; on the CLI, you'd use `ailang run --ai claude-haiku-4-5` or `--ai gemini-2-5-flash` or any supported model. The AILANG extraction code is identical regardless of provider.

The pipeline has 3-tier graceful degradation:

| Tier | Requires | Pipeline |
|------|----------|----------|
| **Tier 1** | WASM AI handler + API key | Full AILANG pipeline — `processDocument` / `processFile` with `! {AI}` effect |
| **Tier 2** | API key only | JS calls Gemini → AILANG `validateOnly` (pure validation) |
| **Tier 3** | Nothing | Pre-extracted demo data → AILANG `validateOnly` |

In all three tiers, AILANG validates the data. The AI is the stochastic part; AILANG is the deterministic guarantee.

## Features

### Demo Presets

Seven built-in document examples, each with a pre-defined schema and (for text demos) pre-extracted data:

| Demo | Type | Description |
|------|------|-------------|
| Invoice | Text | Vendor, totals, line items from a commercial invoice |
| Receipt | Text | Merchant, items, payment from a retail receipt |
| Contract | Text | Parties, dates, terms from a service agreement |
| Bank Statement | Text | Account details, balances, transaction summary |
| Shipping | Text | Sender, recipient, tracking from a shipping label |
| Resume | Text | Candidate details, experience, education from a CV |
| PDF Invoice | PDF | Real car hire invoice — requires API key for multimodal extraction |

### AI Schema Detection

The **Detect Schema** button sends the current document to Gemini and asks it to suggest field names, types, required flags, and constraints. Works with text, images, and PDFs.

### Multimodal File Upload

Upload images (PNG, JPEG, WebP, BMP) or PDFs directly. Files are read as base64 and passed through the same AILANG pipeline — `std/ai.call()` carries the binary data as a structured JSON request, and the JS AI handler constructs a Gemini `inlineData` request.

| File Type | Max Size | Processing |
|-----------|----------|------------|
| PNG, JPEG, WebP, BMP | 10 MB | base64 → AILANG `processFile` → Gemini `inlineData` |
| PDF | 20 MB | base64 → AILANG `processFile` → Gemini `inlineData` |
| TXT, JSON, CSV | 5 MB | Text → textarea → AILANG `processDocument` |

### Schema Editor

Two-mode schema editor that stays in sync:

- **Visual Editor** — form-based field builder with name, type, required, constraints
- **AILANG Types** — edit the schema directly as AILANG record type syntax

### Generated AILANG Code

Every extraction generates a complete AILANG module visible in the middle column. The generated code uses:

- `std/json` — type-safe JSON parsing with `Option` returns
- `std/ai` — AI effect handler via `call()`
- `std/option` / `std/result` — exhaustive pattern matching on `Some`/`None`, `Ok`/`Err`
- Contracts — `requires`/`ensures` on validation functions
- Effects — `! {AI}` on extraction functions, `pure` on validation

### Pipeline Visualization

Real-time pipeline steps with data-driven logs showing actual runtime values (schema name, field count, export count, file sizes, validation results).

## The AILANG Pipeline

The core of the demo is a dynamically generated AILANG module. Here's what gets generated for an invoice schema:

```ailang
module extractor
import std/ai (call)
import std/json (Json, decode, encode, jo, kv, js, jb, getInt, getString, getOrElse)
import std/option (Option, Some, None)
import std/result (Result, Ok, Err)
import std/string (trim, length)
import std/math (intToFloat)

-- Schema type
type InvoiceExtraction = {
  invoice_number: string,
  vendor_name: string,
  total_cents: int
}

-- AI extraction: effectful, calls Gemini via host handler
func extractFields(document: string) -> string ! {AI} {
  let prompt = "Extract these fields as JSON..." ++ document in
  call(prompt)
}

-- Multimodal extraction: base64 file data through std/ai
func extractFromFile(base64Data: string, mimeType: string) -> string ! {AI} {
  let request = encode(jo([
    kv("mode", js("multimodal")),
    kv("mimeType", js(mimeType)),
    kv("data", js(base64Data)),
    kv("prompt", js("Extract these fields as JSON..."))
  ])) in
  call(request)
}

-- Pure validation with contracts
export pure func validateOnly(jsonString: string) -> string
  requires { length(trim(jsonString)) > 0 }
  ensures  { result != "" }
= match decode(jsonString) {
    Err(e) => encodeError("Invalid JSON: " ++ e),
    Ok(jsonObj) => match parseInvoiceExtraction(jsonObj) {
      None => encodeError("Failed to parse fields"),
      Some(record) => match validateFields(record) {
        Some(err) => encodeError(err),
        None => encodeResult(record)
      }
    }
  }
```

## Local Development

### Prerequisites

- A local web server (Python, Node.js, or any HTTP server)
- AILANG WASM files (downloaded automatically by CI, or manually)

### Setup

1. **Clone the repository**:
   ```bash
   git clone https://github.com/sunholo-data/ailang-demos.git
   cd ailang-demos/invoice_processor_wasm
   ```

2. **Get AILANG WASM files** (3 files needed in `wasm/`):
   ```bash
   # Download from latest release
   wget https://github.com/sunholo-data/ailang/releases/latest/download/ailang-wasm.tar.gz
   tar -xzf ailang-wasm.tar.gz -C wasm/
   rm ailang-wasm.tar.gz
   ```

   You need: `ailang.wasm`, `wasm_exec.js`, and `ailang-repl.js`

3. **Start a local server**:
   ```bash
   python3 -m http.server 8000
   # or
   npx http-server -p 8000
   ```

4. **Open** `http://localhost:8000`

### Using a Gemini API Key

For live AI extraction (Tier 1 and Tier 2), add a Gemini API key:

1. Get a free key from [Google AI Studio](https://aistudio.google.com/apikey)
2. Click the **Demo Mode** badge in the top-right
3. Paste your key and click **Save**

The key is stored in `localStorage` only — never sent anywhere except Google's API.

## Project Structure

```
invoice_processor_wasm/
├── index.html                  # Main page — toolbar, pipeline, 3-column layout
├── css/
│   └── styles.css              # Design system (Sunholo brand tokens)
├── js/
│   ├── app.js                  # Pipeline orchestrator — 3-tier execution
│   ├── ailang-wrapper.js       # WASM engine — module loading, AI handler, async calls
│   ├── gemini-client.js        # Gemini Flash API client — text, multimodal, schema detect
│   ├── schema-compiler.js      # Schema → AILANG module code generator
│   ├── schema-editor.js        # Visual + AILANG type editor (two-mode, synced)
│   ├── output-formatter.js     # Result display — JSON, table, AILANG views
│   └── examples.js             # 7 demo scenarios with schemas and pre-extracted data
├── assets/
│   ├── extraction-demo-ui.png  # Screenshot
│   └── bristol-car-hire-demo.pdf  # PDF demo file
├── wasm/
│   ├── ailang.wasm             # AILANG WASM interpreter (downloaded by CI)
│   ├── wasm_exec.js            # Go WASM runtime
│   ├── ailang-repl.js          # REPL wrapper with module API
│   └── invoice_processor.ail   # Legacy invoice processor module
└── README.md
```

## Deployment

Deployed to GitHub Pages via `.github/workflows/deploy-invoice-processor.yml`. The workflow:

1. Downloads the latest AILANG WASM release tarball
2. Extracts `ailang.wasm`, `wasm_exec.js`, `ailang-repl.js` into `wasm/`
3. Deploys `invoice_processor_wasm/` as a static site

## AILANG Features Showcased

| Feature | How It's Used |
|---------|---------------|
| `! {AI}` effect | AI extraction functions declare the effect; host provides Gemini handler |
| `requires`/`ensures` | Validation functions have non-empty input/output contracts |
| `std/json` | Type-safe JSON parsing — `getString`, `getInt` return `Option` |
| `std/option` | `Some`/`None` pattern matching on every field access |
| `std/result` | `Ok`/`Err` handling for JSON decode |
| `std/ai` | `call()` invokes the registered AI handler |
| `pure func` | Validation is side-effect free |
| Record types | Schema compiles to AILANG record type |
| Capability security | WASM sandbox; AI capability injected by JS host |

## References

- [Live Demo](https://sunholo-data.github.io/ailang-demos/)
- [Demo Source Code](https://github.com/sunholo-data/ailang-demos/tree/main/invoice_processor_wasm)
- [AILANG Documentation](https://ailang.sunholo.com/)
- [AILANG Source](https://github.com/sunholo-data/ailang)
- [WASM Integration Guide](https://ailang.sunholo.com/docs/guides/wasm-integration)
- [Language Reference](https://ailang.sunholo.com/docs/reference/language-syntax)
