id: contract_interval_overlap
description: "Interval overlap with 3-way merge — tight contracts catch off-by-one and containment bugs"
difficulty: hard
category: algorithm_from_spec
languages: ["ailang"]
entrypoint: "main"
caps: ["IO"]

contract_spec: |
  -- Overlap of two half-open intervals [s1,e1) and [s2,e2).
  -- Contract IS the specification: result == max(0, min(e1,e2) - max(s1,s2))
  -- Plus: overlap can never exceed either interval's length.
  export pure func overlap(s1: int, e1: int, s2: int, e2: int) -> int
    requires { s1 <= e1, s2 <= e2 }
    ensures { result >= 0, result <= e1 - s1, result <= e2 - s2 }

  -- 3-way overlap: result can never exceed any single interval's length
  export pure func overlap3(s1: int, e1: int, s2: int, e2: int, s3: int, e3: int) -> int
    requires { s1 <= e1, s2 <= e2, s3 <= e3 }
    ensures { result >= 0, result <= e1 - s1, result <= e2 - s2, result <= e3 - s3 }

  -- Union length of two intervals (inclusion-exclusion)
  export pure func unionLength(s1: int, e1: int, s2: int, e2: int) -> int
    requires { s1 <= e1, s2 <= e2 }
    ensures { result >= e1 - s1, result >= e2 - s2, result <= (e1 - s1) + (e2 - s2) }

  -- Inclusion-exclusion identity must hold
  export pure func inclusionExclusion(s1: int, e1: int, s2: int, e2: int) -> bool
    requires { s1 <= e1, s2 <= e2 }
    ensures { result == true }

z3_hints: |
  overlap ensures result <= e1 - s1 AND result <= e2 - s2 (can't exceed either
  interval length). Off-by-one in min/max logic breaks this.
  overlap3 must compose correctly — nested overlap calls must maintain all three
  upper bounds. unionLength ensures result >= max(either length) — under-counting
  violates the lower bound. inclusionExclusion links overlap and union — if
  either function is off, the identity breaks.

task_prompt: |
  Write an AILANG module for interval overlap calculations on half-open intervals [s,e).

  Functions:
  - `overlap(s1, e1, s2, e2)`: length of overlap between [s1,e1) and [s2,e2).
    Formula: max(0, min(e1,e2) - max(s1,s2))
  - `overlap3(s1, e1, s2, e2, s3, e3)`: 3-way overlap (intersection of all three).
  - `unionLength(s1, e1, s2, e2)`: total covered length (no double-counting).
    Formula: (e1-s1) + (e2-s2) - overlap(s1,e1,s2,e2)
  - `inclusionExclusion(s1, e1, s2, e2)`: proves unionLength == len1 + len2 - overlap

  Main prints (one per line):
    overlap(0, 10, 5, 15)
    overlap(0, 5, 10, 15)
    overlap3(0, 10, 3, 12, 6, 15)
    unionLength(0, 10, 5, 15)
    inclusionExclusion(0, 10, 5, 15)

expected_stdout: |
  5
  0
  4
  15
  true

reference_solution: reference/interval_overlap.ail
