-- Tool declarations and dispatch for the speak CLI voice agent.
--
-- Contract-verified tools following the safe_agent pattern.
-- Each tool returns Result[string, string] — Ok for success, Err for rejection.
--
-- Tools:
--   currentTime  — current date/time via exec("date")
--   calculate    — bounded calculator (inputs clamped, output in [-1M, 1M])
--   readFile     — path-safe file reader (prefix + no ".." traversal)
--   listFiles    — directory listing (path-safe)
--   runCommand   — shell command execution (allowlist: git, gh, ailang, ls, etc.)

module streaming/gemini_live/services/speak_tools

import std/string (length, startsWith, split, substring)
import std/math (floatToInt)
import std/list (length as listLength, any)
import std/result (Ok, Err)
import std/json (decode, encode, getString, getNumber, getArray,
                 jo, kv, js, ja, filterStrings)
import std/option (Some, None, getOrElse)
import std/fs (readFile, fileExists)
import std/process (exec, NotFound, Timeout, NotAllowed)
import std/bytes (toString)

-- ============================================================
-- Tool Declarations
-- ============================================================

export func getSpeakToolDeclarations() -> [{name: string, description: string, parameters: Json}] {
  [
    { name: "currentTime",
      description: "Get the current date, time, and timezone.",
      parameters: jo([kv("type", js("object")), kv("properties", jo([])), kv("required", ja([]))]) },

    { name: "calculate",
      description: "Safe calculator. Operations: add, subtract, multiply, divide. Inputs clamped to [-1000,1000], output guaranteed in [-1000000,1000000].",
      parameters: jo([
        kv("type", js("object")),
        kv("properties", jo([
          kv("op", jo([kv("type", js("string")), kv("enum", ja([js("add"), js("subtract"), js("multiply"), js("divide")]))])),
          kv("a", jo([kv("type", js("number")), kv("description", js("First operand"))])),
          kv("b", jo([kv("type", js("number")), kv("description", js("Second operand"))]))
        ])),
        kv("required", ja([js("op"), js("a"), js("b")]))
      ]) },

    { name: "readFile",
      description: "Read the contents of a text file. The file path must be absolute.",
      parameters: jo([
        kv("type", js("object")),
        kv("properties", jo([
          kv("filepath", jo([kv("type", js("string")), kv("description", js("Absolute path to the file"))]))
        ])),
        kv("required", ja([js("filepath")]))
      ]) },

    { name: "listFiles",
      description: "List files and directories at a given path.",
      parameters: jo([
        kv("type", js("object")),
        kv("properties", jo([
          kv("directory", jo([kv("type", js("string")), kv("description", js("Directory path to list"))]))
        ])),
        kv("required", ja([js("directory")]))
      ]) },

    { name: "runCommand",
      description: "Execute a safe shell command with subcommand filtering. Allowed commands: ls, date, echo, wc, head, tail, grep, pwd, whoami, uname, git (status/log/diff/branch/show/blame/add/commit only — no push/reset/force), gh (pr/issue list/view/status only — no merge/close/create), ailang (messages/check/docs/prompt/version only). Destructive operations are blocked.",
      parameters: jo([
        kv("type", js("object")),
        kv("properties", jo([
          kv("command", jo([kv("type", js("string")), kv("description", js("Command name (must be in allowlist)"))])),
          kv("args", jo([kv("type", js("array")), kv("items", jo([kv("type", js("string"))])), kv("description", js("Command arguments"))]))
        ])),
        kv("required", ja([js("command")]))
      ]) }
  ]
}

-- ============================================================
-- Dispatch
-- ============================================================

export func dispatchTool(name: string, argsJson: string, allowedPath: string) -> Result[string, string] ! {FS, Process} {
  match name {
    "currentTime" => handleCurrentTime(),
    "calculate" => handleCalculate(argsJson),
    "readFile" => handleReadFile(argsJson, allowedPath),
    "listFiles" => handleListFiles(argsJson, allowedPath),
    "runCommand" => handleRunCommand(argsJson),
    _ => Err("Unknown tool: " ++ name)
  }
}

-- ============================================================
-- Tool: Current Time
-- ============================================================

func handleCurrentTime() -> Result[string, string] ! {Process} {
  match exec("date", ["+%Y-%m-%d %H:%M:%S %Z"]) {
    Ok(out) => Ok(toString(out.stdout)),
    Err(NotFound(_)) => Err("date command not found"),
    Err(_) => Err("Failed to get current time")
  }
}

-- ============================================================
-- Tool: Safe Calculator
-- ============================================================

export pure func clampInput(x: int) -> int
  ensures { result >= -1000 && result <= 1000 }
{
  if x > 1000 then 1000
  else if x < -1000 then -1000
  else x
}

pure func opCode(op: string) -> int {
  match op {
    "add" => 1, "subtract" => 2, "multiply" => 3, "divide" => 4,
    _ => 0
  }
}

pure func doCalc(code: int, ca: int, cb: int) -> Option[int] {
  match code {
    1 => Some(ca + cb),
    2 => Some(ca - cb),
    3 => {
      let product = ca * cb;
      if product > 1000000 then Some(1000000)
      else if product < -1000000 then Some(-1000000)
      else Some(product)
    },
    4 => if cb == 0 then None else Some(ca / cb),
    _ => None
  }
}

export func safeCalculate(op: string, a: int, b: int) -> Result[int, string]
  ensures {
    match result {
      Ok(n) => n >= -1000000 && n <= 1000000,
      Err(_) => true
    }
  }
{
  let ca = clampInput(a);
  let cb = clampInput(b);
  match doCalc(opCode(op), ca, cb) {
    Some(n) => Ok(n),
    None => Err("Unknown operation or division by zero: " ++ op)
  }
}

func handleCalculate(argsJson: string) -> Result[string, string] {
  match decode(argsJson) {
    Ok(json) => {
      let op = getOrElse(getString(json, "op"), "");
      let a = match getNumber(json, "a") { Some(n) => floatToInt(n), None => 0 };
      let b = match getNumber(json, "b") { Some(n) => floatToInt(n), None => 0 };
      match safeCalculate(op, a, b) {
        Ok(n) => Ok(show(n)),
        Err(e) => Err(e)
      }
    },
    Err(e) => Err("Invalid args: " ++ e)
  }
}

-- ============================================================
-- Tool: Safe File Reader
-- ============================================================

export pure func containsTraversal(path: string) -> bool {
  let parts = split(path, "/");
  any(\p. p == "..", parts)
}

export pure func isPathSafe(path: string, prefix: string) -> bool
  ensures { result == (startsWith(path, prefix) && containsTraversal(path) == false) }
{
  startsWith(path, prefix) && containsTraversal(path) == false
}

func handleReadFile(argsJson: string, allowedPath: string) -> Result[string, string] ! {FS} {
  match decode(argsJson) {
    Ok(json) => {
      let filepath = getOrElse(getString(json, "filepath"), "");
      if not isPathSafe(filepath, allowedPath) then
        Err("Path rejected: must start with '" ++ allowedPath ++ "' and contain no '..'")
      else if not fileExists(filepath) then
        Err("File not found: " ++ filepath)
      else Ok(readFile(filepath))
    },
    Err(e) => Err("Invalid args: " ++ e)
  }
}

-- ============================================================
-- Tool: List Files
-- ============================================================

func handleListFiles(argsJson: string, allowedPath: string) -> Result[string, string] ! {Process} {
  match decode(argsJson) {
    Ok(json) => {
      let dir = getOrElse(getString(json, "directory"), ".");
      if not isPathSafe(dir, allowedPath) then
        Err("Path rejected: must start with '" ++ allowedPath ++ "' and contain no '..'")
      else {
        match exec("ls", ["-la", dir]) {
          Ok(out) => Ok(toString(out.stdout)),
          Err(NotFound(_)) => Err("ls command not found"),
          Err(_) => Err("Failed to list directory: " ++ dir)
        }
      }
    },
    Err(e) => Err("Invalid args: " ++ e)
  }
}

-- ============================================================
-- Tool: Safe Command Execution
-- ============================================================

pure func isAllowedCommand(cmd: string) -> bool {
  match cmd {
    "ls" => true, "date" => true, "echo" => true, "wc" => true,
    "head" => true, "tail" => true, "grep" => true,
    "pwd" => true, "whoami" => true, "uname" => true,
    "git" => true, "gh" => true, "ailang" => true,
    _ => false
  }
}

-- Git subcommand safety: allow read-only and safe operations,
-- block destructive ones (push, reset, clean, checkout, rebase, etc.)
pure func isGitSubcmdSafe(subcmd: string) -> bool {
  match subcmd {
    "status" => true, "log" => true, "diff" => true, "branch" => true,
    "show" => true, "remote" => true, "tag" => true, "stash" => true,
    "blame" => true, "shortlog" => true, "describe" => true,
    "rev-parse" => true, "ls-files" => true, "ls-tree" => true,
    "cat-file" => true, "reflog" => true, "config" => true,
    "add" => true, "commit" => true,
    _ => false
  }
}

-- gh subcommand safety: allow read/query, block mutations that
-- affect shared state (pr merge, issue close, repo delete, etc.)
pure func isGhSubcmdSafe(subcmd: string) -> bool {
  match subcmd {
    "pr" => true, "issue" => true, "repo" => true, "status" => true,
    "run" => true, "api" => true, "auth" => true,
    _ => false
  }
}

-- gh sub-subcommand safety: for pr/issue/repo, only allow read operations
pure func isGhActionSafe(subcmd: string, action: string) -> bool {
  match subcmd {
    "pr" => match action {
      "list" => true, "view" => true, "status" => true,
      "checks" => true, "diff" => true,
      _ => false
    },
    "issue" => match action {
      "list" => true, "view" => true, "status" => true,
      _ => false
    },
    "repo" => match action {
      "view" => true, "list" => true,
      _ => false
    },
    "run" => match action {
      "list" => true, "view" => true,
      _ => false
    },
    _ => true
  }
}

-- ailang subcommand safety: allow messages, check, docs, prompt
pure func isAilangSubcmdSafe(subcmd: string) -> bool {
  match subcmd {
    "messages" => true, "msg" => true,
    "check" => true, "docs" => true, "prompt" => true,
    "version" => true,
    _ => false
  }
}

-- Validate subcommands for git, gh, ailang
-- Returns Ok(()) if safe, Err(reason) if blocked
pure func validateSubcommands(cmd: string, args: [string]) -> Result[(), string] {
  match cmd {
    "git" => match args {
      [] => Err("git requires a subcommand"),
      sub :: _ => if isGitSubcmdSafe(sub) then Ok(())
        else Err("git subcommand '" ++ sub ++ "' is not allowed. Safe: status, log, diff, branch, show, remote, tag, stash, blame, add, commit")
    },
    "gh" => match args {
      [] => Err("gh requires a subcommand"),
      sub :: rest => if not isGhSubcmdSafe(sub) then
          Err("gh subcommand '" ++ sub ++ "' is not allowed. Safe: pr, issue, repo, status, run, api, auth")
        else match rest {
          [] => Ok(()),
          action :: _ => if isGhActionSafe(sub, action) then Ok(())
            else Err("gh " ++ sub ++ " " ++ action ++ " is not allowed. Use list/view/status only")
        }
    },
    "ailang" => match args {
      [] => Err("ailang requires a subcommand"),
      sub :: _ => if isAilangSubcmdSafe(sub) then Ok(())
        else Err("ailang subcommand '" ++ sub ++ "' is not allowed. Safe: messages, check, docs, prompt, version")
    },
    _ => Ok(())
  }
}

func handleRunCommand(argsJson: string) -> Result[string, string] ! {Process} {
  match decode(argsJson) {
    Ok(json) => {
      let cmd = getOrElse(getString(json, "command"), "");
      let args = match getArray(json, "args") {
        Some(arr) => filterStrings(arr),
        None => []
      };
      if not isAllowedCommand(cmd) then
        Err("Command rejected: '" ++ cmd ++ "' is not in the allowlist (ls, date, echo, wc, head, tail, grep, pwd, whoami, uname, git, gh, ailang)")
      else match validateSubcommands(cmd, args) {
        Err(reason) => Err(reason),
        Ok(_) => match exec(cmd, args) {
          Ok(out) => Ok(toString(out.stdout)),
          Err(NotFound(c)) => Err("Command not found: " ++ c),
          Err(Timeout(ms)) => Err("Command timed out"),
          Err(NotAllowed(c)) => Err("Command not allowed by AILANG: " ++ c),
          Err(_) => Err("Command execution failed")
        }
      }
    },
    Err(e) => Err("Invalid args: " ++ e)
  }
}
