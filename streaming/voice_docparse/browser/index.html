<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AILANG Voice Document Analyst</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-deep: #08090c;
    --bg-primary: #0e1015;
    --bg-raised: #14171d;
    --bg-surface: #1a1e26;
    --bg-hover: #20252e;
    --border: #1c2230;
    --border-active: #2a3348;
    --text: #cdd1da;
    --text-muted: #6b7185;
    --text-dim: #3a3f50;
    --accent: #4a9eff;
    --accent-bright: #6bb3ff;
    --accent-glow: rgba(74,158,255,0.15);
    --accent-dim: #1a3a5c;
    --orange: #e0853a;
    --green: #3dd68c;
    --green-dim: #132e20;
    --red: #e05252;
    --purple: #a07ee8;
    --mono: 'IBM Plex Mono', monospace;
    --sans: 'DM Sans', system-ui, sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; background: var(--bg-deep); color: var(--text); font-family: var(--sans); font-size: 14px; overflow: hidden; }

  .app {
    display: grid;
    grid-template-columns: 1fr 340px;
    grid-template-rows: auto auto 1fr auto;
    height: 100vh;
  }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  .header {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
  }

  .header-left { display: flex; align-items: center; gap: 14px; }

  .title {
    font-family: var(--mono);
    font-size: 14px;
    font-weight: 600;
    color: var(--accent);
  }

  .badge {
    font-family: var(--mono);
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 3px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .badge-ws { background: var(--green-dim); color: var(--green); border: 1px solid #1e4a32; }
  .badge-model { background: var(--bg-surface); color: var(--text-muted); border: 1px solid var(--border); }

  .btn-sm {
    font-family: var(--mono);
    font-size: 10px;
    padding: 4px 10px;
    background: none;
    border: 1px solid var(--border);
    color: var(--text-muted);
    border-radius: 3px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .btn-sm:hover { border-color: var(--accent-dim); color: var(--accent); }

  /* ‚îÄ‚îÄ Config ‚îÄ‚îÄ */
  .config {
    grid-column: 1 / -1;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s, padding 0.3s;
    padding: 0 20px;
  }
  .config.open { max-height: 120px; padding: 12px 20px; }

  .config-row { display: flex; gap: 10px; align-items: center; }
  .config-row label { font-family: var(--mono); font-size: 11px; color: var(--text-muted); min-width: 80px; }
  .config-input {
    flex: 1; background: var(--bg-deep); border: 1px solid var(--border); color: var(--text);
    padding: 6px 10px; border-radius: 3px; font-family: var(--mono); font-size: 12px; outline: none;
  }
  .config-input:focus { border-color: var(--accent-dim); }

  /* ‚îÄ‚îÄ Conversation Panel (left) ‚îÄ‚îÄ */
  .conversation {
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--border);
    overflow: hidden;
  }

  .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .chat-messages::-webkit-scrollbar { width: 5px; }
  .chat-messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .chat-msg { max-width: 90%; animation: fadeIn 0.2s ease-out; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } }

  .chat-user {
    align-self: flex-end;
    background: var(--accent-dim);
    border: 1px solid #1e3a58;
    border-radius: 8px 8px 2px 8px;
    padding: 8px 12px;
    font-size: 13px;
  }

  .chat-agent {
    align-self: flex-start;
    padding: 6px 0;
    font-size: 13px;
    line-height: 1.6;
  }

  .chat-agent .agent-text {
    padding-left: 10px;
    border-left: 2px solid var(--border);
  }

  .chat-tool {
    align-self: flex-start;
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 14px;
    width: 85%;
  }

  .tool-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
    font-family: var(--mono);
    font-size: 11px;
  }
  .tool-icon { color: var(--orange); }
  .tool-name { color: var(--accent); font-weight: 500; }
  .tool-status { margin-left: auto; font-size: 10px; }
  .tool-status.ok { color: var(--green); }
  .tool-status.err { color: var(--red); }

  .tool-result {
    font-family: var(--mono);
    font-size: 11px;
    color: var(--text-muted);
    background: var(--bg-deep);
    border-radius: 3px;
    padding: 8px 10px;
    max-height: 120px;
    overflow-y: auto;
    white-space: pre-wrap;
    line-height: 1.5;
  }

  /* ‚îÄ‚îÄ Chat Input ‚îÄ‚îÄ */
  .chat-input-area {
    padding: 12px 20px;
    background: var(--bg-primary);
    border-top: 1px solid var(--border);
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .mic-btn {
    width: 40px; height: 40px;
    border-radius: 50%;
    border: 2px solid var(--border);
    background: var(--bg-raised);
    color: var(--text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .mic-btn:hover { border-color: var(--accent-dim); color: var(--accent); }
  .mic-btn.active {
    border-color: var(--red);
    background: #2a1010;
    color: var(--red);
    animation: micPulse 1.5s ease-in-out infinite;
  }
  @keyframes micPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(224,82,82,0.3); }
    50% { box-shadow: 0 0 0 8px rgba(224,82,82,0); }
  }

  .text-input {
    flex: 1;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 4px;
    font-family: var(--sans);
    font-size: 13px;
    outline: none;
  }
  .text-input:focus { border-color: var(--accent-dim); }

  .send-btn {
    padding: 8px 14px;
    background: var(--accent);
    color: var(--bg-deep);
    border: none;
    border-radius: 4px;
    font-family: var(--mono);
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .send-btn:hover { background: var(--accent-bright); }
  .send-btn:disabled { background: var(--bg-surface); color: var(--text-dim); cursor: not-allowed; }

  /* ‚îÄ‚îÄ Document Panel (right) ‚îÄ‚îÄ */
  .doc-panel {
    display: flex;
    flex-direction: column;
    background: var(--bg-primary);
    overflow: hidden;
  }

  .doc-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    font-family: var(--mono);
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .doc-upload {
    padding: 24px 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    border-bottom: 1px solid var(--border);
  }

  .upload-zone {
    width: 100%;
    padding: 28px 16px;
    border: 2px dashed var(--border);
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    background: var(--bg-deep);
  }
  .upload-zone:hover { border-color: var(--accent-dim); background: var(--bg-raised); }
  .upload-zone.has-file { border-color: var(--green); border-style: solid; }

  .upload-icon { font-size: 28px; color: var(--text-dim); margin-bottom: 8px; }
  .upload-text { font-size: 12px; color: var(--text-muted); }
  .upload-hint { font-size: 10px; color: var(--text-dim); margin-top: 4px; }

  .file-info {
    width: 100%;
    padding: 10px 12px;
    background: var(--bg-raised);
    border-radius: 4px;
    display: none;
  }
  .file-info.visible { display: block; }
  .file-name { font-family: var(--mono); font-size: 12px; color: var(--accent); }
  .file-meta { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

  /* ‚îÄ‚îÄ Document Stats ‚îÄ‚îÄ */
  .doc-stats {
    padding: 12px 16px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    border-bottom: 1px solid var(--border);
  }

  .stat-card {
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 10px;
  }
  .stat-label { font-family: var(--mono); font-size: 9px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: var(--mono); font-size: 18px; font-weight: 600; color: var(--text); margin-top: 2px; }

  /* ‚îÄ‚îÄ Tool Activity Log ‚îÄ‚îÄ */
  .tool-log {
    flex: 1;
    overflow-y: auto;
    padding: 10px 16px;
  }
  .tool-log::-webkit-scrollbar { width: 4px; }
  .tool-log::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .log-title {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }

  .log-entry {
    display: flex;
    align-items: flex-start;
    gap: 6px;
    padding: 5px 0;
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    animation: fadeIn 0.15s;
  }
  .log-time { font-family: var(--mono); font-size: 9px; color: var(--text-dim); white-space: nowrap; margin-top: 2px; }
  .log-dot { width: 6px; height: 6px; border-radius: 50%; margin-top: 5px; flex-shrink: 0; }
  .log-dot.ok { background: var(--green); }
  .log-dot.pending { background: var(--orange); }
  .log-dot.err { background: var(--red); }
  .log-text { color: var(--text-muted); line-height: 1.4; }

  /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
  .footer {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 20px;
    background: var(--bg-raised);
    border-top: 1px solid var(--border);
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-dim);
  }
  .footer-stats { display: flex; gap: 16px; }
  .footer-stat span { color: var(--text-muted); }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  @media (max-width: 768px) {
    .app { grid-template-columns: 1fr; }
    .doc-panel { display: none; }
    .conversation { border-right: none; }
  }
</style>
<script src="../../wasm/wasm_exec.js"></script>
<script src="../../wasm/ailang-repl.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>

<div class="app">
  <div class="header">
    <div class="header-left">
      <div class="title">AILANG Voice DocParse</div>
      <span class="badge badge-model">gemini-live-2.5-flash</span>
      <span class="badge badge-ws">‚óè WebSocket</span>
    </div>
    <div>
      <button class="btn-sm" onclick="toggleConfig()">‚öô config</button>
    </div>
  </div>

  <div class="config" id="config">
    <div class="config-row">
      <label>Gemini Key</label>
      <input type="password" class="config-input" id="apiKey" placeholder="API key..." onchange="localStorage.setItem('gemini-api-key',this.value)">
    </div>
  </div>

  <!-- Left: Conversation -->
  <div class="conversation">
    <div class="chat-messages" id="chatMessages">
      <div style="text-align:center;padding:40px 20px;color:var(--text-dim);font-size:12px;">
        <div style="font-size:28px;margin-bottom:10px;opacity:0.3;">üìÑ</div>
        Upload a document and ask questions about it.<br>
        The voice agent uses DocParse tools to analyze content.
      </div>
    </div>
    <div class="chat-input-area">
      <button class="mic-btn" id="micBtn" onclick="toggleMic()" title="Toggle microphone">üé§</button>
      <input class="text-input" id="textInput" placeholder="Ask about the document..." onkeydown="if(event.key==='Enter')sendText()">
      <button class="send-btn" id="sendBtn" onclick="sendText()">Send</button>
    </div>
  </div>

  <!-- Right: Document Panel -->
  <div class="doc-panel">
    <div class="doc-header">Document</div>
    <div class="doc-upload">
      <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()" ondragover="event.preventDefault();this.style.borderColor='var(--accent)'" ondragleave="this.style.borderColor=''" ondrop="handleDrop(event)">
        <div class="upload-icon">‚Üë</div>
        <div class="upload-text">Drop DOCX, PPTX, or XLSX</div>
        <div class="upload-hint">or click to browse</div>
      </div>
      <input type="file" id="fileInput" accept=".docx,.pptx,.xlsx,.pdf" style="display:none" onchange="handleFile(this.files[0])">
      <div class="file-info" id="fileInfo">
        <div class="file-name" id="fileName"></div>
        <div class="file-meta" id="fileMeta"></div>
      </div>
    </div>

    <div class="doc-stats">
      <div class="stat-card"><div class="stat-label">Paragraphs</div><div class="stat-val" id="statParagraphs">‚Äî</div></div>
      <div class="stat-card"><div class="stat-label">Tables</div><div class="stat-val" id="statTables">‚Äî</div></div>
      <div class="stat-card"><div class="stat-label">Images</div><div class="stat-val" id="statImages">‚Äî</div></div>
      <div class="stat-card"><div class="stat-label">Headings</div><div class="stat-val" id="statHeadings">‚Äî</div></div>
    </div>

    <div class="tool-log" id="toolLog">
      <div class="log-title">Tool Activity</div>
    </div>
  </div>

  <div class="footer">
    <div class="footer-stats">
      <div class="footer-stat">tools: <span id="fToolCalls">0</span></div>
      <div class="footer-stat">messages: <span id="fMessages">0</span></div>
      <div class="footer-stat">stream: <span id="fStreamStatus">disconnected</span></div>
    </div>
    <div>ailang √ó gemini live</div>
  </div>
</div>

<script>
let ws = null;
let isRecording = false;
let audioCtx = null;
let captureNode = null;
let currentFile = null;
let pendingText = null;   // queued text to send after setupComplete
let sessionReady = false; // true after setupComplete received

// WASM DocParse state
let wasmEngine = null;
let wasmReady = false;
let wasmLoading = false;
let docXml = {};          // extracted XML from ZIP: { 'word/document.xml': '...', ... }
let docBlocks = null;     // cached parsed blocks JSON string
const DOCPARSE_MODULE = 'docparse/services/docparse_browser';
const DOCPARSE_MODULES = [
  { name: 'docparse/types/document',           path: '../../ailang/docparse/types/document.ail' },
  { name: 'docparse/services/format_router',    path: '../../ailang/docparse/services/format_router.ail' },
  { name: 'docparse/services/zip_extract',      path: '../../ailang/docparse/services/zip_extract.ail' },
  { name: 'docparse/services/docx_parser',      path: '../../ailang/docparse/services/docx_parser.ail' },
  { name: 'docparse/services/pptx_parser',      path: '../../ailang/docparse/services/pptx_parser.ail' },
  { name: 'docparse/services/xlsx_parser',      path: '../../ailang/docparse/services/xlsx_parser.ail' },
  { name: 'docparse/services/output_formatter', path: '../../ailang/docparse/services/output_formatter.ail' },
  { name: 'docparse/services/docparse_browser', path: '../../ailang/docparse/services/docparse_browser.ail' },
];

function toggleConfig() { document.getElementById('config').classList.toggle('open'); }

// ‚îÄ‚îÄ File handling ‚îÄ‚îÄ
function handleDrop(e) {
  e.preventDefault();
  e.currentTarget.style.borderColor = '';
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
}

async function handleFile(file) {
  if (!file) return;
  currentFile = file;
  const zone = document.getElementById('uploadZone');
  zone.classList.add('has-file');
  zone.querySelector('.upload-icon').textContent = '‚úì';
  zone.querySelector('.upload-text').textContent = file.name;
  zone.querySelector('.upload-hint').textContent = formatBytes(file.size);

  document.getElementById('fileInfo').classList.add('visible');
  document.getElementById('fileName').textContent = file.name;
  document.getElementById('fileMeta').textContent = `${formatBytes(file.size)} ¬∑ ${file.type || 'unknown'}`;

  addLog('pending', `File loaded: ${file.name}`);

  // Extract XML from ZIP for WASM parsing
  await extractDocumentXml(file);

  // Ensure WASM is loading
  if (!wasmReady && !wasmLoading) initWASM();
}

function formatBytes(b) {
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b/1024).toFixed(1) + ' KB';
  return (b/1048576).toFixed(1) + ' MB';
}

// ‚îÄ‚îÄ WASM DocParse Engine ‚îÄ‚îÄ
async function initWASM() {
  if (wasmReady || wasmLoading) return;
  wasmLoading = true;
  addLog('pending', 'Loading AILANG WASM runtime...');
  try {
    if (typeof AilangREPL === 'undefined') {
      addLog('err', 'WASM runtime not available (ailang-repl.js not loaded)');
      return;
    }
    const repl = new AilangREPL();
    await repl.init('../../wasm/ailang.wasm');
    for (const lib of ['std/json', 'std/option', 'std/result', 'std/string', 'std/math', 'std/xml', 'std/list', 'std/io']) {
      repl.importModule(lib);
    }
    for (let i = 0; i < DOCPARSE_MODULES.length; i++) {
      const mod = DOCPARSE_MODULES[i];
      addLog('pending', `Loading ${mod.name.split('/').pop()} (${i+1}/${DOCPARSE_MODULES.length})`);
      const resp = await fetch(mod.path + '?v=' + Date.now());
      if (!resp.ok) throw new Error(`Failed to fetch ${mod.path}`);
      const code = await resp.text();
      const result = repl.loadModule(mod.name, code);
      if (!result.success) throw new Error(`Module ${mod.name}: ${result.error}`);
    }
    wasmEngine = repl;
    wasmReady = true;
    addLog('ok', 'AILANG DocParse ready');
  } catch (e) {
    addLog('err', 'WASM init failed: ' + e.message);
    console.error('WASM init error:', e);
  } finally {
    wasmLoading = false;
  }
}

async function extractDocumentXml(file) {
  docXml = {};
  docBlocks = null;
  const buffer = await file.arrayBuffer();
  const ext = file.name.split('.').pop().toLowerCase();
  if (['docx', 'pptx', 'xlsx'].includes(ext)) {
    addLog('pending', 'Extracting ZIP contents...');
    const zip = await JSZip.loadAsync(buffer);
    for (const entry of Object.keys(zip.files)) {
      if (entry.endsWith('.xml') && !zip.files[entry].dir) {
        try { docXml[entry] = await zip.files[entry].async('string'); } catch (e) { /* skip */ }
      }
    }
    addLog('ok', `Extracted ${Object.keys(docXml).length} XML entries`);
  }
}

function callAILANG(funcName, ...args) {
  if (!wasmReady) return { success: false, error: 'WASM not ready' };
  try {
    const result = wasmEngine.call(DOCPARSE_MODULE, funcName, ...args);
    if (!result.success) return { success: false, error: result.error };
    let val = result.result || '';
    const typeMatch = val.match(/^(.+) :: \w+$/s);
    if (typeMatch) val = typeMatch[1];
    if (val.startsWith('"') && val.endsWith('"')) {
      try { val = JSON.parse(val); } catch { val = val.slice(1, -1); }
    }
    return { success: true, result: val };
  } catch (e) {
    return { success: false, error: e.message };
  }
}

function ensureBlocksParsed() {
  if (docBlocks) return true;
  if (!currentFile) return false;
  const ext = currentFile.name.split('.').pop().toLowerCase();
  if (ext === 'docx' && docXml['word/document.xml']) {
    const r = callAILANG('parseDocxBody', docXml['word/document.xml']);
    if (r.success) { docBlocks = r.result; return true; }
  } else if (ext === 'pptx') {
    const slideXmls = Object.keys(docXml)
      .filter(k => k.startsWith('ppt/slides/slide') && k.endsWith('.xml') && !k.includes('_rels'))
      .sort();
    const all = [];
    for (const key of slideXmls) {
      const r = callAILANG('parsePptxSlide', docXml[key]);
      if (r.success) try { all.push(...JSON.parse(r.result)); } catch {}
    }
    docBlocks = JSON.stringify(all); return true;
  } else if (ext === 'xlsx') {
    const ss = docXml['xl/sharedStrings.xml'] || '';
    const sheets = Object.keys(docXml)
      .filter(k => k.startsWith('xl/worksheets/sheet') && k.endsWith('.xml'))
      .sort();
    const all = [];
    for (const key of sheets) {
      const r = callAILANG('parseXlsxSheet', docXml[key], ss, key);
      if (r.success) try { all.push(...JSON.parse(r.result)); } catch {}
    }
    docBlocks = JSON.stringify(all); return true;
  }
  return false;
}

function getDocParseResult(toolName, toolArgs) {
  if (!wasmReady) return 'AILANG WASM is still loading. Please wait and try again.';
  if (!currentFile || Object.keys(docXml).length === 0) return 'No document uploaded. Please upload a DOCX, PPTX, or XLSX file first.';
  if (!ensureBlocksParsed()) return 'Failed to parse document.';

  let blocks;
  try { blocks = JSON.parse(docBlocks); } catch { return 'Failed to parse document blocks.'; }

  switch (toolName) {
    case 'parseDocument': return blocksToText(blocks);
    case 'extractTables': {
      const tables = blocks.filter(b => b.type === 'table');
      if (!tables.length) return 'No tables found in document.';
      return `Found ${tables.length} table(s):\n\n` + tables.map((t, i) => {
        const hdr = (t.headers || []).join(' | ');
        const rows = (t.rows || []).map(r => (r || []).join(' | ')).join('\n');
        return `Table ${i+1}:\n${hdr}\n${rows}`;
      }).join('\n\n');
    }
    case 'extractHeadings': {
      const h = blocks.filter(b => b.type === 'heading');
      if (!h.length) return 'No headings found in document.';
      return `Document outline (${h.length} headings):\n` + h.map((x, i) =>
        `${'  '.repeat((x.level||1)-1)}${i+1}. ${x.text||''}`).join('\n');
    }
    case 'countContent': {
      const c = { paragraph: 0, table: 0, image: 0, heading: 0 };
      (function count(items) {
        for (const b of items) {
          if (b.type === 'text' || b.type === 'change') c.paragraph++;
          else if (b.type === 'table') c.table++;
          else if (b.type === 'image') c.image++;
          else if (b.type === 'heading') c.heading++;
          if (b.type === 'section' && b.blocks) count(b.blocks);
        }
      })(blocks);
      document.getElementById('statParagraphs').textContent = c.paragraph;
      document.getElementById('statTables').textContent = c.table;
      document.getElementById('statImages').textContent = c.image;
      document.getElementById('statHeadings').textContent = c.heading;
      return `Document contains: ${c.paragraph} paragraphs, ${c.table} tables, ${c.image} images, ${c.heading} headings (${blocks.length} blocks total)`;
    }
    case 'searchDocument': {
      const query = toolArgs?.query || '';
      if (!query) return 'No search query provided.';
      const lq = query.toLowerCase();
      const matches = [];
      blocks.forEach((b, i) => {
        const text = b.text || '';
        if (text.toLowerCase().includes(lq))
          matches.push(`Block ${i+1} (${b.type}): ${text.substring(0, 120)}${text.length > 120 ? '...' : ''}`);
      });
      return matches.length ? `Found ${matches.length} match(es) for "${query}":\n` + matches.join('\n')
        : `No matches found for "${query}".`;
    }
    default: return 'Unknown tool: ' + toolName;
  }
}

function blocksToText(blocks) {
  let md = '';
  for (const b of blocks) {
    if (b.type === 'heading') md += '#'.repeat(b.level||1) + ' ' + (b.text||'') + '\n\n';
    else if (b.type === 'text') md += (b.text||'') + '\n\n';
    else if (b.type === 'table') {
      if (b.headers?.length) { md += '| ' + b.headers.join(' | ') + ' |\n'; md += '| ' + b.headers.map(() => '---').join(' | ') + ' |\n'; }
      if (b.rows) for (const row of b.rows) md += '| ' + (row||[]).join(' | ') + ' |\n';
      md += '\n';
    } else if (b.type === 'image') md += `[Image: ${b.description||'embedded'}]\n\n`;
    else if (b.type === 'section' && b.blocks) md += blocksToText(b.blocks);
    else if (b.type === 'change') md += `[${b.changeType||'change'} by ${b.author||'unknown'}] ${b.text||''}\n\n`;
  }
  return md || 'Document parsed but no text content found.';
}

// ‚îÄ‚îÄ WebSocket ‚îÄ‚îÄ
function connectGemini() {
  const key = document.getElementById('apiKey').value || localStorage.getItem('gemini-api-key');
  if (!key) { addLog('err', 'No API key ‚Äî open config to set one'); toggleConfig(); return; }
  sessionReady = false;

  const url = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1beta.GenerativeService.BidiGenerateContent?key=${key}`;
  ws = new WebSocket(url);

  ws.onopen = () => {
    document.getElementById('fStreamStatus').textContent = 'connected';
    addLog('ok', 'WebSocket connected');
    sendSetup();
  };

  ws.onmessage = async (e) => {
    let text;
    if (typeof e.data === 'string') text = e.data;
    else if (e.data instanceof Blob) text = await e.data.text();
    else if (e.data instanceof ArrayBuffer) text = new TextDecoder().decode(e.data);
    else return;
    try { handleServerMessage(JSON.parse(text)); }
    catch (err) { console.error('Failed to parse:', text.substring(0, 100)); }
  };

  ws.onclose = (e) => {
    sessionReady = false;
    document.getElementById('fStreamStatus').textContent = 'disconnected';
    addLog('err', `WebSocket closed (code: ${e.code}${e.reason ? ', ' + e.reason : ''})`);
  };

  ws.onerror = (e) => {
    addLog('err', 'WebSocket error');
    console.error('WebSocket error:', e);
  };
}

function sendSetup() {
  const tools = [
    { name: 'parseDocument', description: 'Parse document content as markdown', parameters: { type: 'object', properties: { filepath: { type: 'string' } }, required: ['filepath'] } },
    { name: 'extractTables', description: 'Extract tables from document', parameters: { type: 'object', properties: { filepath: { type: 'string' } }, required: ['filepath'] } },
    { name: 'extractHeadings', description: 'Get document outline', parameters: { type: 'object', properties: { filepath: { type: 'string' } }, required: ['filepath'] } },
    { name: 'countContent', description: 'Count paragraphs, tables, images, headings', parameters: { type: 'object', properties: { filepath: { type: 'string' } }, required: ['filepath'] } },
    { name: 'searchDocument', description: 'Search text in document', parameters: { type: 'object', properties: { filepath: { type: 'string' }, query: { type: 'string' } }, required: ['filepath', 'query'] } }
  ];

  const setup = {
    setup: {
      model: 'models/gemini-live-2.5-flash-preview',
      generationConfig: { responseModalities: ['TEXT'] },
      systemInstruction: { parts: [{ text: 'You are a document analyst. Use the available tools to parse and analyze documents. Summarize results clearly.' }] },
      tools: [{ functionDeclarations: tools }]
    }
  };
  ws.send(JSON.stringify(setup));
}

function handleServerMessage(data) {
  const count = parseInt(document.getElementById('fMessages').textContent) + 1;
  document.getElementById('fMessages').textContent = count;

  if (data.setupComplete) {
    sessionReady = true;
    addLog('ok', 'Session ready');
    addAgentMessage('Ready! Ask me about your document.');
    // Flush any queued text
    if (pendingText) {
      const text = pendingText;
      pendingText = null;
      sendMessage(text);
    }
    return;
  }

  if (data.toolCall) {
    const calls = data.toolCall.functionCalls || [];
    calls.forEach(call => {
      const tc = parseInt(document.getElementById('fToolCalls').textContent) + 1;
      document.getElementById('fToolCalls').textContent = tc;
      addLog('pending', `Tool: ${call.name}`);
      const result = getDocParseResult(call.name, call.args);
      addToolCard(call.name, JSON.stringify(call.args || {}), result);
      addLog('ok', `${call.name} completed`);
      sendToolResponse(call.id, result);
    });
    return;
  }

  if (data.serverContent) {
    if (data.serverContent.turnComplete) return;
    const parts = data.serverContent?.modelTurn?.parts || [];
    parts.forEach(p => {
      if (p.text) addAgentMessage(p.text);
    });
  }
}

function sendToolResponse(id, result) {
  if (!ws) return;
  ws.send(JSON.stringify({
    toolResponse: { functionResponses: [{ id, name: '', response: { result } }] }
  }));
}

// ‚îÄ‚îÄ Chat UI ‚îÄ‚îÄ
function addUserMessage(text) {
  const el = document.createElement('div');
  el.className = 'chat-msg chat-user';
  el.textContent = text;
  document.getElementById('chatMessages').appendChild(el);
  scrollChat();
}

function addAgentMessage(text) {
  const el = document.createElement('div');
  el.className = 'chat-msg chat-agent';
  el.innerHTML = `<div class="agent-text">${escapeHtml(text)}</div>`;
  document.getElementById('chatMessages').appendChild(el);
  scrollChat();
}

function addToolCard(name, args, result) {
  const el = document.createElement('div');
  el.className = 'chat-msg chat-tool';
  el.innerHTML = `
    <div class="tool-header">
      <span class="tool-icon">‚ö°</span>
      <span class="tool-name">${name}</span>
      <span class="tool-status ok">‚úì ok</span>
    </div>
    <div class="tool-result">${escapeHtml(result)}</div>`;
  document.getElementById('chatMessages').appendChild(el);
  scrollChat();
}

function scrollChat() {
  const c = document.getElementById('chatMessages');
  c.scrollTop = c.scrollHeight;
}

function escapeHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function sendMessage(text) {
  if (ws && ws.readyState === 1 && sessionReady) {
    ws.send(JSON.stringify({
      clientContent: {
        turns: [{ role: 'user', parts: [{ text }] }],
        turnComplete: true
      }
    }));
  }
}

function sendText() {
  const input = document.getElementById('textInput');
  const text = input.value.trim();
  if (!text) return;
  addUserMessage(text);
  input.value = '';
  if (!ws || ws.readyState !== 1) {
    pendingText = text;
    connectGemini();
  } else {
    sendMessage(text);
  }
}

// ‚îÄ‚îÄ Mic ‚îÄ‚îÄ
async function toggleMic() {
  const btn = document.getElementById('micBtn');
  if (isRecording) {
    isRecording = false;
    btn.classList.remove('active');
    if (captureNode) captureNode.port.postMessage({ command: 'stop' });
  } else {
    if (!audioCtx) {
      audioCtx = new AudioContext({ sampleRate: 48000 });
      await audioCtx.audioWorklet.addModule('../shared/audio-worklet.js');
    }
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioCtx.createMediaStreamSource(stream);
    captureNode = new AudioWorkletNode(audioCtx, 'pcm-capture', { processorOptions: { targetRate: 16000 } });
    source.connect(captureNode);
    captureNode.port.onmessage = (e) => {
      if (e.data.type === 'pcm-chunk' && ws && ws.readyState === 1 && sessionReady) {
        const b64 = arrayBufferToBase64(e.data.pcmData);
        ws.send(JSON.stringify({
          realtimeInput: { mediaChunks: [{ mimeType: 'audio/pcm;rate=16000', data: b64 }] }
        }));
      }
    };
    isRecording = true;
    btn.classList.add('active');
    if (!ws || ws.readyState !== 1) connectGemini();
  }
}

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

// ‚îÄ‚îÄ Tool Log ‚îÄ‚îÄ
function addLog(status, text) {
  const log = document.getElementById('toolLog');
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  entry.innerHTML = `<span class="log-time">${time}</span><span class="log-dot ${status}"></span><span class="log-text">${text}</span>`;
  log.appendChild(entry);
  log.scrollTop = log.scrollHeight;
}

// Init
document.addEventListener('DOMContentLoaded', () => {
  if (!localStorage.getItem('gemini-api-key') && localStorage.getItem('gemini_key')) localStorage.setItem('gemini-api-key', localStorage.getItem('gemini_key'));
  const k = localStorage.getItem('gemini-api-key');
  if (k) document.getElementById('apiKey').value = k;
  // Start loading AILANG WASM engine
  initWASM();
});
</script>
<script src="../shared/nav.js"></script>
</body>
</html>
