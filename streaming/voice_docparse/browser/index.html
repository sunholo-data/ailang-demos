<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AILANG Voice Document Analyst</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-deep: #08090c;
    --bg-primary: #0e1015;
    --bg-raised: #14171d;
    --bg-surface: #1a1e26;
    --bg-hover: #20252e;
    --border: #1c2230;
    --border-active: #2a3348;
    --text: #cdd1da;
    --text-muted: #6b7185;
    --text-dim: #3a3f50;
    --accent: #4a9eff;
    --accent-bright: #6bb3ff;
    --accent-glow: rgba(74,158,255,0.15);
    --accent-dim: #1a3a5c;
    --orange: #e0853a;
    --green: #3dd68c;
    --green-dim: #132e20;
    --red: #e05252;
    --red-dim: #2a1010;
    --purple: #a07ee8;
    --mono: 'IBM Plex Mono', monospace;
    --sans: 'DM Sans', system-ui, sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; background: var(--bg-deep); color: var(--text); font-family: var(--sans); font-size: 14px; overflow: hidden; }

  .app {
    display: grid;
    grid-template-columns: 1fr 340px;
    grid-template-rows: auto auto auto 1fr auto;
    height: 100vh;
  }

  /* â”€â”€ Header â”€â”€ */
  .header {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
  }

  .header-left { display: flex; align-items: center; gap: 14px; }

  .title {
    font-family: var(--mono);
    font-size: 14px;
    font-weight: 600;
    color: var(--accent);
  }

  .badge {
    font-family: var(--mono);
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 3px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .badge-ws {
    background: var(--green-dim);
    color: var(--green);
    border: 1px solid #1e4a32;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .badge-ws .dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--text-dim);
    transition: background 0.3s;
  }
  .badge-ws.live .dot {
    background: var(--green);
    box-shadow: 0 0 6px rgba(61,214,140,0.5);
    animation: pulse-dot 2s ease-in-out infinite;
  }
  @keyframes pulse-dot {
    0%, 100% { box-shadow: 0 0 4px rgba(61,214,140,0.3); }
    50% { box-shadow: 0 0 10px rgba(61,214,140,0.6); }
  }
  .badge-model { background: var(--bg-surface); color: var(--text-muted); border: 1px solid var(--border); }
  .badge-fallback {
    display: none;
    background: var(--red-dim);
    color: var(--red);
    border: 1px solid #4a1515;
    animation: pulse-warn 1.5s ease-in-out infinite;
  }
  .badge-fallback.active { display: inline-block; }
  @keyframes pulse-warn { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

  .header-right { display: flex; align-items: center; gap: 8px; }

  .btn-sm {
    font-family: var(--mono);
    font-size: 10px;
    padding: 4px 10px;
    background: none;
    border: 1px solid var(--border);
    color: var(--text-muted);
    border-radius: 3px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .btn-sm:hover { border-color: var(--accent-dim); color: var(--accent); }

  /* â”€â”€ Fallback banner â”€â”€ */
  .fallback-banner {
    grid-column: 1 / -1;
    display: none;
    background: var(--red-dim);
    border-bottom: 1px solid #4a1515;
    color: var(--red);
    font-size: 11px;
    font-weight: 500;
    padding: 6px 16px;
    text-align: center;
  }
  .fallback-banner.active { display: block; }

  /* â”€â”€ Config â”€â”€ */
  .config {
    grid-column: 1 / -1;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s, padding 0.3s;
    padding: 0 20px;
  }
  .config.open { max-height: 140px; padding: 12px 20px; }

  .config-row { display: flex; gap: 10px; align-items: center; margin-bottom: 6px; }
  .config-row:last-child { margin-bottom: 0; }
  .config-row label { font-family: var(--mono); font-size: 11px; color: var(--text-muted); min-width: 80px; }
  .config-input, .config-select {
    flex: 1; background: var(--bg-deep); border: 1px solid var(--border); color: var(--text);
    padding: 6px 10px; border-radius: 3px; font-family: var(--mono); font-size: 12px; outline: none;
  }
  .config-input:focus, .config-select:focus { border-color: var(--accent-dim); }

  /* â”€â”€ Scope strip â”€â”€ */
  .scope-strip {
    grid-column: 1 / -1;
    height: 80px;
    background: var(--bg-deep);
    border-bottom: 1px solid var(--border);
    position: relative;
    overflow: hidden;
  }
  .scope-strip canvas {
    width: 100%;
    height: 80px;
    display: block;
  }
  .scope-strip .vu-strip {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 3px 12px;
    background: rgba(0,0,0,0.4);
  }
  .vu-label { font-family: var(--mono); font-size: 8px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
  .vu-track { flex: 1; height: 3px; background: var(--bg-surface); border-radius: 2px; overflow: hidden; }
  .vu-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent) 0%, var(--accent-bright) 80%, var(--red) 100%); border-radius: 2px; transition: width 0.1s ease-out; }
  .vu-db { font-family: var(--mono); font-size: 8px; color: var(--text-dim); min-width: 36px; text-align: right; }

  /* â”€â”€ Conversation Panel (left) â”€â”€ */
  .conversation {
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--border);
    overflow: hidden;
  }

  .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .chat-messages::-webkit-scrollbar { width: 5px; }
  .chat-messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .chat-msg { max-width: 90%; animation: fadeIn 0.2s ease-out; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } }

  .chat-user {
    align-self: flex-end;
    background: var(--accent-dim);
    border: 1px solid #1e3a58;
    border-radius: 8px 8px 2px 8px;
    padding: 8px 12px;
    font-size: 13px;
  }

  .chat-agent {
    align-self: flex-start;
    padding: 6px 0;
    font-size: 13px;
    line-height: 1.6;
  }

  .chat-agent .agent-text {
    padding-left: 10px;
    border-left: 2px solid var(--border);
  }

  .chat-tool {
    align-self: flex-start;
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 14px;
    width: 85%;
  }

  .tool-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
    font-family: var(--mono);
    font-size: 11px;
  }
  .tool-icon { color: var(--orange); }
  .tool-name { color: var(--accent); font-weight: 500; }
  .tool-status { margin-left: auto; font-size: 10px; }
  .tool-status.ok { color: var(--green); }
  .tool-status.err { color: var(--red); }

  .tool-result {
    font-family: var(--mono);
    font-size: 11px;
    color: var(--text-muted);
    background: var(--bg-deep);
    border-radius: 3px;
    padding: 8px 10px;
    max-height: 120px;
    overflow-y: auto;
    white-space: pre-wrap;
    line-height: 1.5;
  }

  /* â”€â”€ Chat Input â”€â”€ */
  .chat-input-area {
    padding: 12px 20px;
    background: var(--bg-primary);
    border-top: 1px solid var(--border);
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .mic-btn {
    width: 40px; height: 40px;
    border-radius: 50%;
    border: 2px solid var(--border);
    background: var(--bg-raised);
    color: var(--text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .mic-btn:hover { border-color: var(--accent-dim); color: var(--accent); }
  .mic-btn.active {
    border-color: var(--red);
    background: #2a1010;
    color: var(--red);
    animation: micPulse 1.5s ease-in-out infinite;
  }
  @keyframes micPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(224,82,82,0.3); }
    50% { box-shadow: 0 0 0 8px rgba(224,82,82,0); }
  }

  .text-input {
    flex: 1;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 4px;
    font-family: var(--sans);
    font-size: 13px;
    outline: none;
  }
  .text-input:focus { border-color: var(--accent-dim); }

  .send-btn {
    padding: 8px 14px;
    background: var(--accent);
    color: var(--bg-deep);
    border: none;
    border-radius: 4px;
    font-family: var(--mono);
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .send-btn:hover { background: var(--accent-bright); }
  .send-btn:disabled { background: var(--bg-surface); color: var(--text-dim); cursor: not-allowed; }

  /* â”€â”€ Document Panel (right) â”€â”€ */
  .doc-panel {
    display: flex;
    flex-direction: column;
    background: var(--bg-primary);
    overflow: hidden;
  }

  .doc-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    font-family: var(--mono);
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .doc-upload {
    padding: 24px 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    border-bottom: 1px solid var(--border);
  }

  .upload-zone {
    width: 100%;
    padding: 28px 16px;
    border: 2px dashed var(--border);
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    background: var(--bg-deep);
  }
  .upload-zone:hover { border-color: var(--accent-dim); background: var(--bg-raised); }
  .upload-zone.has-file { border-color: var(--green); border-style: solid; }

  .upload-icon { font-size: 28px; color: var(--text-dim); margin-bottom: 8px; }
  .upload-text { font-size: 12px; color: var(--text-muted); }
  .upload-hint { font-size: 10px; color: var(--text-dim); margin-top: 4px; }

  .file-info {
    width: 100%;
    padding: 10px 12px;
    background: var(--bg-raised);
    border-radius: 4px;
    display: none;
  }
  .file-info.visible { display: block; }
  .file-name { font-family: var(--mono); font-size: 12px; color: var(--accent); }
  .file-meta { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

  /* â”€â”€ Document Stats â”€â”€ */
  .doc-stats {
    padding: 12px 16px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    border-bottom: 1px solid var(--border);
  }

  .stat-card {
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 10px;
  }
  .stat-label { font-family: var(--mono); font-size: 9px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: var(--mono); font-size: 18px; font-weight: 600; color: var(--text); margin-top: 2px; }

  /* â”€â”€ Tool Activity Log â”€â”€ */
  .tool-log {
    flex: 1;
    overflow-y: auto;
    padding: 10px 16px;
  }
  .tool-log::-webkit-scrollbar { width: 4px; }
  .tool-log::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .log-title {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }

  .log-entry {
    display: flex;
    align-items: flex-start;
    gap: 6px;
    padding: 5px 0;
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    animation: fadeIn 0.15s;
  }
  .log-time { font-family: var(--mono); font-size: 9px; color: var(--text-dim); white-space: nowrap; margin-top: 2px; }
  .log-dot { width: 6px; height: 6px; border-radius: 50%; margin-top: 5px; flex-shrink: 0; }
  .log-dot.ok { background: var(--green); }
  .log-dot.pending { background: var(--orange); }
  .log-dot.err { background: var(--red); }
  .log-dot.info { background: var(--text-dim); }
  .log-dot.audio { background: var(--accent); box-shadow: 0 0 4px rgba(74,158,255,0.4); }
  .log-text { color: var(--text-muted); line-height: 1.4; }
  .log-text .hl { color: var(--accent); }
  .log-text .val { color: var(--text); }

  /* â”€â”€ Footer â”€â”€ */
  .footer {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 20px;
    background: var(--bg-raised);
    border-top: 1px solid var(--border);
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-dim);
  }
  .footer-stats { display: flex; gap: 16px; }
  .footer-stat span { color: var(--text-muted); }

  /* â”€â”€ Responsive â”€â”€ */
  @media (max-width: 768px) {
    .app { grid-template-columns: 1fr; }
    .doc-panel { display: none; }
    .conversation { border-right: none; }
    .scope-strip { height: 60px; }
    .scope-strip canvas { height: 60px; }
  }
</style>
<script src="../../wasm/wasm_exec.js"></script>
<script src="../../wasm/ailang-repl.js"></script>
<script src="../shared/gemini-live-core.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>

<div class="app">
  <div class="header">
    <div class="header-left">
      <div class="title">AILANG Voice DocParse</div>
      <span class="badge badge-model">gemini-2.5-flash-native-audio</span>
      <span class="badge badge-ws" id="wssBadge"><span class="dot"></span>WSS</span>
      <span class="badge badge-fallback" id="fallbackBadge">FALLBACK</span>
    </div>
    <div class="header-right">
      <button class="btn-sm" onclick="toggleConfig()">Config</button>
      <button class="btn-sm" onclick="connectGemini()" id="connectBtn">Connect</button>
    </div>
  </div>
  <div class="fallback-banner" id="fallbackBanner">AILANG closure failed â€” running in JS fallback mode. Events processed via AILANG pure functions.</div>

  <div class="config" id="configPanel">
    <div class="config-row">
      <label>Gemini Key</label>
      <input type="password" class="config-input" id="apiKey" placeholder="API key..." onchange="saveConfig()">
    </div>
    <div class="config-row">
      <label>Voice</label>
      <select class="config-select" id="voiceSelect" onchange="saveConfig()">
        <option value="Sulafat">Sulafat (Warm)</option>
      </select>
    </div>
  </div>

  <!-- Scope strip (audio waveform) -->
  <div class="scope-strip">
    <canvas id="waveform"></canvas>
    <div class="vu-strip">
      <span class="vu-label">VU</span>
      <div class="vu-track"><div class="vu-fill" id="vuFill"></div></div>
      <span class="vu-db" id="vuDb">-âˆž dB</span>
    </div>
  </div>

  <!-- Left: Conversation -->
  <div class="conversation">
    <div class="chat-messages" id="chatMessages">
      <div style="text-align:center;padding:40px 20px;color:var(--text-dim);font-size:12px;">
        <div style="font-size:28px;margin-bottom:10px;opacity:0.3;">ðŸ“„</div>
        Upload a document, then ask questions by voice or text.<br>
        The agent uses AILANG DocParse tools to analyze content<br>
        and responds with voice via Gemini Live audio.
      </div>
    </div>
    <div class="chat-input-area">
      <button class="mic-btn" id="micBtn" onclick="toggleMic()" title="Toggle microphone">ðŸŽ¤</button>
      <input class="text-input" id="textInput" placeholder="Ask about the document..." onkeydown="if(event.key==='Enter')sendText()">
      <button class="send-btn" id="sendBtn" onclick="sendText()">Send</button>
    </div>
  </div>

  <!-- Right: Document Panel -->
  <div class="doc-panel">
    <div class="doc-header">Document</div>
    <div class="doc-upload">
      <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()" ondragover="event.preventDefault();this.style.borderColor='var(--accent)'" ondragleave="this.style.borderColor=''" ondrop="handleDrop(event)">
        <div class="upload-icon">â†‘</div>
        <div class="upload-text">Drop DOCX, PPTX, or XLSX</div>
        <div class="upload-hint">or click to browse</div>
      </div>
      <input type="file" id="fileInput" accept=".docx,.pptx,.xlsx,.pdf" style="display:none" onchange="handleFile(this.files[0])">
      <div class="file-info" id="fileInfo">
        <div class="file-name" id="fileName"></div>
        <div class="file-meta" id="fileMeta"></div>
      </div>
    </div>

    <div class="doc-stats">
      <div class="stat-card"><div class="stat-label">Paragraphs</div><div class="stat-val" id="statParagraphs">â€”</div></div>
      <div class="stat-card"><div class="stat-label">Tables</div><div class="stat-val" id="statTables">â€”</div></div>
      <div class="stat-card"><div class="stat-label">Images</div><div class="stat-val" id="statImages">â€”</div></div>
      <div class="stat-card"><div class="stat-label">Headings</div><div class="stat-val" id="statHeadings">â€”</div></div>
    </div>

    <div class="tool-log" id="toolLog">
      <div class="log-title">Activity Log</div>
    </div>
  </div>

  <div class="footer">
    <div class="footer-stats">
      <div class="footer-stat">tools: <span id="fToolCalls">0</span></div>
      <div class="footer-stat">audio: <span id="fAudioFrames">0</span></div>
      <div class="footer-stat">stream: <span id="fStreamStatus">idle</span></div>
    </div>
    <div>ailang Ã— gemini live Ã— docparse wasm</div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Voice DocParse â€” AILANG WASM Streaming + Document Analysis
//
// Uses GeminiLiveCore (shared library) for WASM init, Stream effect
// handlers, audio pipeline, and waveform visualization.
// Loads both the Gemini Live streaming module (protocol) and all
// DocParse modules (document parsing) into the same WASM engine.
//
// Voice responses via Gemini Live native audio.
// Tool calls dispatched to DocParse WASM functions.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ DOM cache â”€â”€
const $ = {};
function cacheDom() {
  for (const id of [
    'wssBadge', 'fallbackBanner', 'fallbackBadge', 'configPanel',
    'apiKey', 'voiceSelect', 'chatMessages', 'textInput', 'sendBtn',
    'micBtn', 'connectBtn', 'toolLog', 'vuFill', 'vuDb',
    'fToolCalls', 'fAudioFrames', 'fStreamStatus',
    'statParagraphs', 'statTables', 'statImages', 'statHeadings',
  ]) {
    $[id] = document.getElementById(id);
  }
}

// â”€â”€ Module names â”€â”€
const STREAM_MODULE = 'streaming/gemini_live/gemini_live_browser';
const DOCPARSE_MODULE = 'docparse/services/docparse_browser';

// â”€â”€ GeminiLiveCore instance â”€â”€
const core = new GeminiLiveCore({
  modules: [
    { name: STREAM_MODULE,                          path: '../../ailang/streaming/gemini_live/gemini_live_browser.ail' },
    { name: 'docparse/types/document',              path: '../../ailang/docparse/types/document.ail' },
    { name: 'docparse/services/format_router',      path: '../../ailang/docparse/services/format_router.ail' },
    { name: 'docparse/services/zip_extract',        path: '../../ailang/docparse/services/zip_extract.ail' },
    { name: 'docparse/services/docx_parser',        path: '../../ailang/docparse/services/docx_parser.ail' },
    { name: 'docparse/services/pptx_parser',        path: '../../ailang/docparse/services/pptx_parser.ail' },
    { name: 'docparse/services/xlsx_parser',        path: '../../ailang/docparse/services/xlsx_parser.ail' },
    { name: 'docparse/services/output_formatter',   path: '../../ailang/docparse/services/output_formatter.ail' },
    { name: DOCPARSE_MODULE,                        path: '../../ailang/docparse/services/docparse_browser.ail' },
  ],
  stdlibs: ['std/json', 'std/option', 'std/result', 'std/string', 'std/list', 'std/io', 'std/stream', 'std/xml', 'std/math'],
  playbackRate: 48000,
  sourceRate: 24000,
  micRate: 16000,
  fftSize: 2048,
  canvasHeight: 80,
  onEvent: handleAILANGEvent,
  onLog: (type, html) => addLog(type, html),
  onStatsUpdate: (stats) => {
    $.fAudioFrames.textContent = stats.frames;
    if (core.lastPcmChunk) {
      const vu = core.computeVU(core.lastPcmChunk);
      $.vuFill.style.width = vu.pct + '%';
      $.vuDb.textContent = vu.db > -60 ? vu.db.toFixed(1) + ' dB' : '-âˆž dB';
    }
  },
  onConnectionChange: (state) => {
    if (state === 'connected') $.wssBadge.classList.add('live');
    else $.wssBadge.classList.remove('live');
  },
  onFallbackActivated: () => {
    $.fallbackBanner.classList.add('active');
    $.fallbackBadge.classList.add('active');
  },
  onFallbackDeactivated: () => {
    $.fallbackBanner.classList.remove('active');
    $.fallbackBadge.classList.remove('active');
  },
  onWasmReady: () => populateVoicesFromAILANG(),
  onWasmError: () => {},
});

// â”€â”€ Config â”€â”€
const SYSTEM_INSTRUCTION = 'You are a document analyst voice assistant powered by AILANG. ' +
  'When the user asks about a document, use the available tools to parse and analyze it. ' +
  'Use countContent first to understand structure, then other tools as needed. ' +
  'Speak with a British English accent. Keep responses conversational and concise. ' +
  'If no document is uploaded, ask the user to upload one first.';

// â”€â”€ Document state â”€â”€
let currentFile = null;
let docXml = {};
let docBlocks = null;

// â”€â”€ Logging â”€â”€
function addLog(status, text) {
  if (!$.toolLog) return;
  const el = document.createElement('div');
  el.className = 'log-entry';
  const now = new Date();
  const ts = String(now.getHours()).padStart(2,'0') + ':' +
             String(now.getMinutes()).padStart(2,'0') + ':' +
             String(now.getSeconds()).padStart(2,'0');
  el.innerHTML = `<span class="log-time">${ts}</span><span class="log-dot ${status}"></span><span class="log-text">${text}</span>`;
  $.toolLog.appendChild(el);
  $.toolLog.scrollTop = $.toolLog.scrollHeight;
}

// â”€â”€ Config management â”€â”€
function toggleConfig() { $.configPanel.classList.toggle('open'); }

function loadConfig() {
  if (!localStorage.getItem('gemini-api-key') && localStorage.getItem('gemini_key'))
    localStorage.setItem('gemini-api-key', localStorage.getItem('gemini_key'));
  const k = localStorage.getItem('gemini-api-key');
  if (k) $.apiKey.value = k;
  const v = localStorage.getItem('gemini-live-voice');
  if (v) $.voiceSelect.value = v;
}

function saveConfig() {
  const key = $.apiKey.value.trim();
  if (key) localStorage.setItem('gemini-api-key', key);
  localStorage.setItem('gemini-live-voice', $.voiceSelect.value);
}

function populateVoicesFromAILANG() {
  if (!core.wasmReady) return;
  try {
    const raw = core.callAILANG('voiceCatalog');
    if (!raw) return;
    const voices = JSON.parse(raw);
    const current = $.voiceSelect.value;
    $.voiceSelect.innerHTML = '';
    voices.forEach(v => {
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.textContent = `${v.name} (${v.desc})`;
      $.voiceSelect.appendChild(opt);
    });
    const saved = localStorage.getItem('gemini-live-voice');
    $.voiceSelect.value = saved || current || 'Sulafat';
  } catch (e) { console.error('Voice catalog error:', e); }
}

// â”€â”€ File handling â”€â”€
function handleDrop(e) {
  e.preventDefault();
  e.currentTarget.style.borderColor = '';
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
}

async function handleFile(file) {
  if (!file) return;
  currentFile = file;
  const zone = document.getElementById('uploadZone');
  zone.classList.add('has-file');
  zone.querySelector('.upload-icon').textContent = 'âœ“';
  zone.querySelector('.upload-text').textContent = file.name;
  zone.querySelector('.upload-hint').textContent = GeminiLiveCore.fmtBytes(file.size);
  document.getElementById('fileInfo').classList.add('visible');
  document.getElementById('fileName').textContent = file.name;
  document.getElementById('fileMeta').textContent = `${GeminiLiveCore.fmtBytes(file.size)} Â· ${file.type || 'unknown'}`;
  addLog('pending', `File loaded: <span class="val">${GeminiLiveCore.escapeHtml(file.name)}</span>`);
  await extractDocumentXml(file);
}

async function extractDocumentXml(file) {
  docXml = {};
  docBlocks = null;
  const buffer = await file.arrayBuffer();
  const ext = file.name.split('.').pop().toLowerCase();
  if (['docx', 'pptx', 'xlsx'].includes(ext)) {
    addLog('pending', 'Extracting ZIP contents...');
    const zip = await JSZip.loadAsync(buffer);
    for (const entry of Object.keys(zip.files)) {
      if (entry.endsWith('.xml') && !zip.files[entry].dir) {
        try { docXml[entry] = await zip.files[entry].async('string'); } catch {}
      }
    }
    addLog('ok', `Extracted <span class="val">${Object.keys(docXml).length}</span> XML entries`);
  }
}

// â”€â”€ DocParse WASM calls â”€â”€
function callDocParse(funcName, ...args) {
  if (!core.wasmReady) return { success: false, error: 'WASM not ready' };
  const result = core.callAILANGModule(DOCPARSE_MODULE, funcName, ...args);
  if (result === null) return { success: false, error: 'call failed' };
  return { success: true, result };
}

function ensureBlocksParsed() {
  if (docBlocks) return true;
  if (!currentFile) return false;
  const ext = currentFile.name.split('.').pop().toLowerCase();
  if (ext === 'docx' && docXml['word/document.xml']) {
    const r = callDocParse('parseDocxBody', docXml['word/document.xml']);
    if (r.success) { docBlocks = r.result; return true; }
  } else if (ext === 'pptx') {
    const slideXmls = Object.keys(docXml)
      .filter(k => k.startsWith('ppt/slides/slide') && k.endsWith('.xml') && !k.includes('_rels'))
      .sort();
    const all = [];
    for (const key of slideXmls) {
      const r = callDocParse('parsePptxSlide', docXml[key]);
      if (r.success) try { all.push(...JSON.parse(r.result)); } catch {}
    }
    docBlocks = JSON.stringify(all); return true;
  } else if (ext === 'xlsx') {
    const ss = docXml['xl/sharedStrings.xml'] || '';
    const sheets = Object.keys(docXml)
      .filter(k => k.startsWith('xl/worksheets/sheet') && k.endsWith('.xml'))
      .sort();
    const all = [];
    for (const key of sheets) {
      const r = callDocParse('parseXlsxSheet', docXml[key], ss, key);
      if (r.success) try { all.push(...JSON.parse(r.result)); } catch {}
    }
    docBlocks = JSON.stringify(all); return true;
  }
  return false;
}

function getDocParseResult(toolName, toolArgs) {
  if (!core.wasmReady) return 'AILANG WASM is still loading. Please wait and try again.';
  if (!currentFile || Object.keys(docXml).length === 0) return 'No document uploaded. Please upload a DOCX, PPTX, or XLSX file first.';
  if (!ensureBlocksParsed()) return 'Failed to parse document.';

  let blocks;
  try { blocks = JSON.parse(docBlocks); } catch { return 'Failed to parse document blocks.'; }

  switch (toolName) {
    case 'parseDocument': return blocksToText(blocks);
    case 'extractTables': {
      const tables = blocks.filter(b => b.type === 'table');
      if (!tables.length) return 'No tables found in document.';
      return `Found ${tables.length} table(s):\n\n` + tables.map((t, i) => {
        const hdr = (t.headers || []).join(' | ');
        const rows = (t.rows || []).map(r => (r || []).join(' | ')).join('\n');
        return `Table ${i+1}:\n${hdr}\n${rows}`;
      }).join('\n\n');
    }
    case 'extractHeadings': {
      const h = blocks.filter(b => b.type === 'heading');
      if (!h.length) return 'No headings found in document.';
      return `Document outline (${h.length} headings):\n` + h.map((x, i) =>
        `${'  '.repeat((x.level||1)-1)}${i+1}. ${x.text||''}`).join('\n');
    }
    case 'countContent': {
      const c = { paragraph: 0, table: 0, image: 0, heading: 0 };
      (function count(items) {
        for (const b of items) {
          if (b.type === 'text' || b.type === 'change') c.paragraph++;
          else if (b.type === 'table') c.table++;
          else if (b.type === 'image') c.image++;
          else if (b.type === 'heading') c.heading++;
          if (b.type === 'section' && b.blocks) count(b.blocks);
        }
      })(blocks);
      $.statParagraphs.textContent = c.paragraph;
      $.statTables.textContent = c.table;
      $.statImages.textContent = c.image;
      $.statHeadings.textContent = c.heading;
      return `Document contains: ${c.paragraph} paragraphs, ${c.table} tables, ${c.image} images, ${c.heading} headings (${blocks.length} blocks total)`;
    }
    case 'searchDocument': {
      const query = toolArgs?.query || '';
      if (!query) return 'No search query provided.';
      const lq = query.toLowerCase();
      const matches = [];
      blocks.forEach((b, i) => {
        const text = b.text || '';
        if (text.toLowerCase().includes(lq))
          matches.push(`Block ${i+1} (${b.type}): ${text.substring(0, 120)}${text.length > 120 ? '...' : ''}`);
      });
      return matches.length ? `Found ${matches.length} match(es) for "${query}":\n` + matches.join('\n')
        : `No matches found for "${query}".`;
    }
    default: return 'Unknown tool: ' + toolName;
  }
}

function blocksToText(blocks) {
  let md = '';
  for (const b of blocks) {
    if (b.type === 'heading') md += '#'.repeat(b.level||1) + ' ' + (b.text||'') + '\n\n';
    else if (b.type === 'text') md += (b.text||'') + '\n\n';
    else if (b.type === 'table') {
      if (b.headers?.length) { md += '| ' + b.headers.join(' | ') + ' |\n'; md += '| ' + b.headers.map(() => '---').join(' | ') + ' |\n'; }
      if (b.rows) for (const row of b.rows) md += '| ' + (row||[]).join(' | ') + ' |\n';
      md += '\n';
    } else if (b.type === 'image') md += `[Image: ${b.description||'embedded'}]\n\n`;
    else if (b.type === 'section' && b.blocks) md += blocksToText(b.blocks);
    else if (b.type === 'change') md += `[${b.changeType||'change'} by ${b.author||'unknown'}] ${b.text||''}\n\n`;
  }
  return md || 'Document parsed but no text content found.';
}

// â”€â”€ Tool declarations for Gemini â”€â”€
function getToolDeclarations() {
  return [{
    functionDeclarations: [
      { name: 'parseDocument', description: 'Parse the uploaded document and return its full content as markdown. Use this to read document text.', parameters: { type: 'object', properties: {} } },
      { name: 'extractTables', description: 'Extract all tables from the document with headers and rows.', parameters: { type: 'object', properties: {} } },
      { name: 'extractHeadings', description: 'Get the document outline showing all headings and their hierarchy.', parameters: { type: 'object', properties: {} } },
      { name: 'countContent', description: 'Count paragraphs, tables, images, and headings in the document.', parameters: { type: 'object', properties: {} } },
      { name: 'searchDocument', description: 'Search for specific text within the document.', parameters: { type: 'object', properties: { query: { type: 'string', description: 'Text to search for' } }, required: ['query'] } },
    ]
  }];
}

// â”€â”€ Event handler â”€â”€
function handleAILANGEvent(event) {
  switch (event.type) {
    case 'log':
      addLog('info', GeminiLiveCore.escapeHtml(event.text || ''));
      break;
    case 'setup':
      core.sessionReady = true;
      $.fStreamStatus.textContent = 'ready';
      addLog('ok', '<span class="hl">Setup complete</span> â€” AILANG streaming session with tools');
      break;
    case 'sent':
      addLog('info', 'Sent: <span class="val">' + GeminiLiveCore.escapeHtml(event.text || '') + '</span>');
      $.fStreamStatus.textContent = 'streaming';
      core.markPromptSent();
      break;
    case 'turnComplete':
      core.sessionReady = true;
      resetAgentBubble();
      $.fStreamStatus.textContent = 'ready';
      addLog('ok', '<span class="hl">Turn complete</span> â€” <span class="val">' +
        core.stats.frames + '</span> audio frames');
      $.sendBtn.disabled = false;
      $.textInput.disabled = false;
      break;
    case 'inputTranscript':
      if (event.text) {
        addUserMessage(event.text);
        addLog('info', 'You: <span class="val">' + GeminiLiveCore.escapeHtml(event.text) + '</span>');
      }
      break;
    case 'outputTranscript':
      if (event.text) {
        appendAgentText(event.text);
        addLog('info', 'Agent: <span class="val">' + GeminiLiveCore.escapeHtml(event.text) + '</span>');
      }
      break;
    case 'modelTurn':
      if (event.parts && Array.isArray(event.parts)) {
        event.parts.forEach(part => {
          if (part.text) appendAgentText(part.text);
          if (part.inlineData && part.inlineData.data) core.handleAudioFrame(part.inlineData.data);
        });
      }
      break;
    case 'toolCall':
      resetAgentBubble();  // tool cards get their own section
      if (event.calls) {
        event.calls.forEach(call => {
          const tc = parseInt($.fToolCalls.textContent) + 1;
          $.fToolCalls.textContent = tc;
          addLog('pending', `Tool call: <span class="hl">${GeminiLiveCore.escapeHtml(call.name)}</span>`);
          const result = getDocParseResult(call.name, call.args);
          addToolCard(call.name, call.args, result);
          addLog('ok', `<span class="hl">${GeminiLiveCore.escapeHtml(call.name)}</span> completed`);
          // Send tool response via AILANG
          const resp = core.callAILANG('buildToolResponse', call.id, call.name, result);
          const conn = core.getActiveConnection();
          if (conn && resp) conn.ws.send(resp);
          else if (conn) {
            // Fallback: build response directly
            conn.ws.send(JSON.stringify({
              toolResponse: { functionResponses: [{ id: call.id, name: call.name, response: { result } }] }
            }));
          }
        });
      }
      break;
    case 'opened':
      $.fStreamStatus.textContent = 'connected';
      addLog('ok', 'WebSocket connected (AILANG Stream effect)');
      break;
    case 'closed':
      core.sessionReady = false;
      $.fStreamStatus.textContent = 'disconnected';
      $.wssBadge.classList.remove('live');
      addLog('info', 'Session closed');
      $.connectBtn.textContent = 'Connect';
      break;
    case 'error':
      addLog('err', GeminiLiveCore.escapeHtml(event.text || 'Unknown error'));
      break;
  }
}

// â”€â”€ Chat UI (accumulating agent messages) â”€â”€
let _agentEl = null;

function addUserMessage(text) {
  _agentEl = null;  // new user message breaks the agent bubble
  const el = document.createElement('div');
  el.className = 'chat-msg chat-user';
  el.textContent = text;
  $.chatMessages.appendChild(el);
  $.chatMessages.scrollTop = $.chatMessages.scrollHeight;
}

// Append text to the current agent bubble (or create one)
function appendAgentText(text) {
  if (!text) return;
  if (!_agentEl) {
    _agentEl = document.createElement('div');
    _agentEl.className = 'chat-msg chat-agent';
    _agentEl.innerHTML = '<div class="agent-text"></div>';
    $.chatMessages.appendChild(_agentEl);
  }
  const inner = _agentEl.querySelector('.agent-text');
  if (inner.textContent) inner.textContent += ' ' + text;
  else inner.textContent = text;
  $.chatMessages.scrollTop = $.chatMessages.scrollHeight;
}

function resetAgentBubble() { _agentEl = null; }

function addToolCard(name, args, result) {
  const el = document.createElement('div');
  el.className = 'chat-msg chat-tool';
  el.innerHTML = `
    <div class="tool-header">
      <span class="tool-icon">âš¡</span>
      <span class="tool-name">${GeminiLiveCore.escapeHtml(name)}</span>
      <span class="tool-status ok">âœ“ ok</span>
    </div>
    <div class="tool-result">${GeminiLiveCore.escapeHtml(typeof result === 'string' ? result : JSON.stringify(result))}</div>`;
  $.chatMessages.appendChild(el);
  $.chatMessages.scrollTop = $.chatMessages.scrollHeight;
}

// â”€â”€ Connect to Gemini Live with tools â”€â”€
async function connectGemini(initialPrompt) {
  const key = $.apiKey.value.trim() || localStorage.getItem('gemini-api-key');
  if (!key) { toggleConfig(); addLog('err', 'Enter your Gemini API key'); return; }
  saveConfig();

  if (!core.wasmReady) {
    addLog('err', 'AILANG WASM not loaded â€” cannot start session');
    return;
  }

  core.sessionReady = false;
  core.resetStats();
  $.fStreamStatus.textContent = 'connecting';
  $.sendBtn.disabled = true;
  $.textInput.disabled = true;
  $.connectBtn.textContent = 'Connecting...';
  core.deactivateFallbackMode();

  await core.initAudio();

  const voice = $.voiceSelect.value;
  const toolsJson = JSON.stringify(getToolDeclarations());
  let prompt = initialPrompt || '';
  if (!prompt && currentFile) {
    prompt = 'Hello! I have uploaded a document called "' + currentFile.name + '". ' +
      'Please use your tools to analyze it â€” start with countContent to see what it contains.';
  } else if (!prompt) {
    prompt = 'Hello! I may have a document to analyze.';
  }
  core.sessionPrompt = prompt;

  addLog('info', 'Starting AILANG session with <span class="hl">tools</span> (std/stream effects)...');

  try {
    const result = await core.wasmEngine.callAsync(
      STREAM_MODULE, 'startSessionWithTools',
      key, voice, SYSTEM_INSTRUCTION, prompt, toolsJson
    );
    if (!result.success) addLog('err', 'Session error: ' + GeminiLiveCore.escapeHtml(result.error || 'unknown'));
    else addLog('info', 'Session ended: <span class="val">' + (result.result || 'complete') + '</span>');
  } catch (e) {
    addLog('err', 'Session failed: ' + GeminiLiveCore.escapeHtml(e.message));
  }

  core.sessionReady = false;
  $.fStreamStatus.textContent = 'disconnected';
  $.connectBtn.textContent = 'Connect';
}

// â”€â”€ Send text â”€â”€
function sendText() {
  const text = $.textInput.value.trim();
  if (!text) return;
  addUserMessage(text);
  $.textInput.value = '';

  if (!core.getActiveConnection()) {
    connectGemini(text);
    return;
  }

  const msgJson = core.callAILANG('buildTextMessage', text);
  const conn = core.getActiveConnection();
  if (conn && msgJson) conn.ws.send(msgJson);
  else if (conn) {
    conn.ws.send(JSON.stringify({
      clientContent: { turns: [{ role: 'user', parts: [{ text }] }], turnComplete: true }
    }));
  }

  core.resetStats();
  core.markPromptSent();
  core.clearAudioQueue();
  $.sendBtn.disabled = true;
  $.textInput.disabled = true;
  $.fStreamStatus.textContent = 'streaming';
}

// â”€â”€ Microphone â”€â”€
async function toggleMic() {
  if (core.isRecording) {
    await core.toggleMic(() => {});
    $.micBtn.classList.remove('active');
    return;
  }
  const started = await core.toggleMic((b64) => {
    const conn = core.getActiveConnection();
    if (conn && core.sessionReady) {
      const chunkJson = core.callAILANG('buildAudioChunk', b64);
      conn.ws.send(chunkJson || JSON.stringify({
        realtimeInput: { mediaChunks: [{ mimeType: 'audio/pcm;rate=16000', data: b64 }] }
      }));
    }
  });
  if (started) {
    $.micBtn.classList.add('active');
    if (!core.getActiveConnection()) connectGemini('');
  }
}

// â”€â”€ Init â”€â”€
window.addEventListener('load', async () => {
  cacheDom();
  loadConfig();
  core.initWaveform(document.getElementById('waveform'));

  addLog('info', 'Loading AILANG WASM â€” streaming + DocParse modules...');
  await core.initWASM();

  if (core.wasmReady) {
    addLog('ok', 'AILANG <span class="hl">std/stream effects</span> + <span class="hl">DocParse WASM</span> ready');
    addLog('info', 'Upload a document and click <span class="val">Connect</span> or type a question');
  } else {
    addLog('err', 'AILANG WASM failed to load');
  }
});
</script>
</body>
</html>
