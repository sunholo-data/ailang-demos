module docparse/services/format_router

import std/string (length, substring, find, split)
import std/list (last)
import std/option (Some, None)

-- Format detection and routing
-- Determines the file format from extension and selects parsing strategy.
-- All functions are pure with inline tests.

-- Supported format categories
-- "zip-office" = docx, pptx, xlsx (ZIP archives with XML)
-- "pdf"        = PDF files
-- "image"      = PNG, JPG, etc (AI-only parsing)
-- "audio"      = WAV, MP3, etc (AI-only parsing)
-- "video"      = MP4, MOV, etc (AI-only parsing)
-- "text"       = Plain text, markdown, etc
-- "unknown"    = Unrecognized format

export pure func detectFormat(ext: string) -> string
  tests [
    ("docx", "zip-office"),
    ("pptx", "zip-office"),
    ("xlsx", "zip-office"),
    ("pdf", "pdf"),
    ("png", "image"),
    ("jpg", "image"),
    ("jpeg", "image"),
    ("wav", "audio"),
    ("mp3", "audio"),
    ("flac", "audio"),
    ("mp4", "video"),
    ("mov", "video"),
    ("webm", "video"),
    ("txt", "text"),
    ("md", "text"),
    ("csv", "text"),
    ("xml", "text"),
    ("foo", "unknown")
  ]
{
  match ext {
    "docx" => "zip-office",
    "pptx" => "zip-office",
    "xlsx" => "zip-office",
    "pdf" => "pdf",
    "png" => "image",
    "jpg" => "image",
    "jpeg" => "image",
    "gif" => "image",
    "bmp" => "image",
    "webp" => "image",
    "tiff" => "image",
    "wav" => "audio",
    "mp3" => "audio",
    "aiff" => "audio",
    "aac" => "audio",
    "ogg" => "audio",
    "flac" => "audio",
    "mp4" => "video",
    "mpeg" => "video",
    "mov" => "video",
    "avi" => "video",
    "flv" => "video",
    "mpg" => "video",
    "webm" => "video",
    "wmv" => "video",
    "3gpp" => "video",
    "txt" => "text",
    "md" => "text",
    "csv" => "text",
    "html" => "text",
    "xml" => "text",
    "json" => "text",
    _ => "unknown"
  }
}

-- Determine the specific Office format type
export pure func officeType(ext: string) -> string
  tests [
    ("docx", "word"),
    ("pptx", "powerpoint"),
    ("xlsx", "excel"),
    ("txt", "unknown")
  ]
{
  match ext {
    "docx" => "word",
    "pptx" => "powerpoint",
    "xlsx" => "excel",
    _ => "unknown"
  }
}

-- Extract file extension from a filename
-- Split on "." and take the last part
-- NOTE: inline tests disabled - test harness can't handle cross-module stdlib calls in pure tests
-- Verified manually: getExtension("report.docx") => "docx", getExtension("noext") => ""
export pure func getExtension(filename: string) -> string {
  let parts = split(filename, ".");
  if hasDot(filename)
  then match last(parts) {
    Some(ext) => ext,
    None => ""
  }
  else ""
}

-- Check if filename contains a dot
pure func hasDot(s: string) -> bool {
  find(s, ".") >= 0
}

-- Determine if a format needs AI processing
export pure func needsAI(format: string) -> bool
  tests [
    ("zip-office", false),
    ("pdf", true),
    ("image", true),
    ("audio", true),
    ("video", true),
    ("text", false),
    ("unknown", true)
  ]
{
  match format {
    "zip-office" => false,
    "text" => false,
    _ => true
  }
}

-- Describe what parsing strategy will be used
export pure func strategyDescription(format: string) -> string
  tests [
    ("zip-office", "ZIP extraction + XML parsing + optional AI for layout"),
    ("pdf", "AI multimodal extraction"),
    ("image", "AI multimodal extraction"),
    ("audio", "AI multimodal extraction (transcription + understanding)"),
    ("video", "AI multimodal extraction (visual + audio understanding)"),
    ("text", "Direct text reading"),
    ("unknown", "AI multimodal extraction (best effort)")
  ]
{
  match format {
    "zip-office" => "ZIP extraction + XML parsing + optional AI for layout",
    "pdf" => "AI multimodal extraction",
    "image" => "AI multimodal extraction",
    "audio" => "AI multimodal extraction (transcription + understanding)",
    "video" => "AI multimodal extraction (visual + audio understanding)",
    "text" => "Direct text reading",
    _ => "AI multimodal extraction (best effort)"
  }
}
