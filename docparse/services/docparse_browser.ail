module docparse/services/docparse_browser

-- Browser adapter for DocParse
-- Thin entry-point module that imports from the original CLI modules
-- and exports WASM-callable functions for JavaScript.
--
-- JavaScript handles ZIP extraction (JSZip); this module handles
-- pure XML -> Block -> JSON conversion.
--
-- This is NOT a standalone module â€” it requires all docparse modules
-- to be loaded in the WASM REPL first (in dependency order).

import std/xml (parse, findAll, findFirst, getText, getAttr, getChildren)
import std/json (encode, jo, kv, js, jb, ja, jnum)
import std/string (length, join)
import std/math (intToFloat)
import std/result (Ok, Err)
import std/option (Some, None, getOrElse, map as optMap)
import std/list (map)
import docparse/types/document (Block, TextBlock, SectionBlock, DocMetadata, emptyMetadata,
    countBlocks, filterHeadings, filterTables, filterImages)
import docparse/services/format_router (detectFormat, getExtension, officeType,
    needsAI, strategyDescription)
import docparse/services/docx_parser (extractBodyBlocks, parseSectionXml,
    hasContent, extractMetadata)
import docparse/services/pptx_parser (extractSlideBlocks)
import docparse/services/xlsx_parser (extractSharedStrings, parseSheetXml)
import docparse/services/output_formatter (blocksToJson, metadataToJson)

-- Parse DOCX body XML (word/document.xml) -> JSON array of blocks
export pure func parseDocxBody(xml: string) -> string {
  match parse(xml) {
    Ok(root) => encode(ja(blocksToJson(extractBodyBlocks(root)))),
    Err(e) => encode(ja([jo([kv("type", js("error")), kv("text", js("XML parse error: " ++ e))])]))
  }
}

-- Parse DOCX section XML (header/footer/footnote/endnote) -> JSON array of blocks
export pure func parseDocxSection(xml: string, kind: string) -> string {
  let blocks = parseSectionXml(xml);
  if hasContent(blocks)
  then encode(ja(blocksToJson([SectionBlock({kind: kind, blocks: blocks})])))
  else encode(ja([]))
}

-- Parse metadata from core.xml -> JSON metadata object
export pure func parseMetadataXml(coreXml: string) -> string {
  match parse(coreXml) {
    Ok(root) => encode(metadataToJson(extractMetadata(root))),
    Err(_) => encode(metadataToJson(emptyMetadata()))
  }
}

-- Parse a single PPTX slide XML -> JSON array of blocks
export pure func parsePptxSlide(slideXml: string) -> string {
  if length(slideXml) == 0 then encode(ja([]))
  else match parse(slideXml) {
    Ok(root) => {
      let blocks = extractSlideBlocks(root);
      if hasContent(blocks)
      then encode(ja(blocksToJson([SectionBlock({kind: "slide", blocks: blocks})])))
      else encode(ja([]))
    },
    Err(_) => encode(ja([]))
  }
}

-- Parse XLSX shared strings XML into string list, then parse sheet XML
export pure func parseXlsxSheet(sheetXml: string, sharedStringsXml: string, sheetName: string) -> string {
  let sharedStrings = parseSharedStringsXml(sharedStringsXml);
  let blocks = parseSheetXml(sheetXml, sharedStrings, sheetName);
  encode(ja(blocksToJson(blocks)))
}

-- Get format info as JSON for a filename
export pure func getFormatInfo(filename: string) -> string {
  let ext = getExtension(filename);
  let format = detectFormat(ext);
  encode(jo([
    kv("extension", js(ext)),
    kv("format", js(format)),
    kv("officeType", js(officeType(ext))),
    kv("needsAI", jb(needsAI(format))),
    kv("strategy", js(strategyDescription(format)))
  ]))
}

-- Parse DOCX comments XML (word/comments.xml) -> JSON array of blocks
-- Each comment becomes a SectionBlock with kind "comment" containing text blocks.
-- The comment text includes the author prefix for context.
export pure func parseDocxComments(xml: string) -> string {
  if length(xml) == 0 then encode(ja([]))
  else match parse(xml) {
    Ok(root) => {
      let comments = findAll(root, "w:comment");
      let blocks = parseCommentNodes(comments);
      encode(ja(blocksToJson(blocks)))
    },
    Err(_) => encode(ja([]))
  }
}

-- Parse a list of w:comment nodes into SectionBlocks
pure func parseCommentNodes(nodes: [XmlNode]) -> [Block] =
  match nodes {
    [] => [],
    node :: rest => {
      let author = getOrElse(getAttr(node, "w:author"), "Unknown");
      let paragraphs = findAll(node, "w:p");
      let texts = extractCommentTexts(paragraphs);
      let commentText = join(" ", texts);
      let block = SectionBlock({kind: "comment", blocks: [
        TextBlock({text: "[" ++ author ++ "] " ++ commentText, style: "CommentText", level: 0})
      ]});
      block :: parseCommentNodes(rest)
    }
  }

-- Extract text from comment paragraphs (find all w:t nodes and join)
pure func extractCommentTexts(paragraphs: [XmlNode]) -> [string] =
  match paragraphs {
    [] => [],
    p :: rest => {
      let tNodes = findAll(p, "w:t");
      let pText = join("", map(getText, tNodes));
      if length(pText) > 0
      then pText :: extractCommentTexts(rest)
      else extractCommentTexts(rest)
    }
  }

-- Helper: parse shared strings XML into a list of strings
-- Handles the same logic as xlsx_parser.loadSharedStrings but pure (no FS)
pure func parseSharedStringsXml(xml: string) -> [string] {
  if length(xml) == 0 then []
  else match parse(xml) {
    Ok(root) => {
      let items = findAll(root, "si");
      extractSharedStrings(items)
    },
    Err(_) => []
  }
}
